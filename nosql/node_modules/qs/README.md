---
ms.openlocfilehash: 334cc21b44dad92ee91fd1f8a2aaf91f242cea2e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051800"
---
# <a name="qs-supversion-badge21sup"></a>qs <sup>[![Version Badge][2]][1]</sup>

[![Buildstatus][3]][4]
[![Abhängigkeitsstatus][5]][6]
[![Entwicklungsabhängigkeitsstatus][7]][8]
[![Lizenz][license-image]][license-url]
[![Downloads][downloads-image]][downloads-url]

[![npm badge][11]][1]

Abfragezeichenfolgen-Analyse- und Stringifizierungsbibliothek mit erweiterter Sicherheit.

Leitender Teambetreuer: [Jordan Harband](https://github.com/ljharb)

Das **qs**-Modul wurde ursprünglich von [TJ Holowaychuk](https://github.com/visionmedia/node-querystring) erstellt und verwaltet.

## <a name="usage"></a>Verbrauch

```javascript
var qs = require('qs');
var assert = require('assert');

var obj = qs.parse('a=c');
assert.deepEqual(obj, { a: 'c' });

var str = qs.stringify(obj);
assert.equal(str, 'a=c');
```

### <a name="parsing-objects"></a>Analysieren von Objekten

[](#preventEval)
```javascript
qs.parse(string, [options]);
```

**qs** ermöglicht es Ihnen, geschachtelte Objekte in Ihren Abfragezeichenfolgen zu erstellen, indem Sie den Namen von Unterschlüsseln in eckige Klammern `[]` setzen.
Die Zeichenfolge `'foo[bar]=baz'` wird z. B. in Folgendes konvertiert:

```javascript
assert.deepEqual(qs.parse('foo[bar]=baz'), {
    foo: {
        bar: 'baz'
    }
});
```

Wenn Sie die Option `plainObjects` verwenden, wird der analysierte Wert als NULL-Objekt zurückgegeben, erstellt über `Object.create(null)` und so sollten Sie sich bewusst sein, dass Prototypmethoden dafür nicht vorhanden sind, und ein Benutzer diese Namen beliebige Werte festlegen kann:

```javascript
var nullObject = qs.parse('a[hasOwnProperty]=b', { plainObjects: true });
assert.deepEqual(nullObject, { a: { hasOwnProperty: 'b' } });
```

Standardmäßig werden Parameter, die Eigenschaften im Objektprototyp überschreiben würden, ignoriert. Wenn Sie die Daten aus diesen Feldern erhalten möchten, verwenden Sie `plainObjects` wie oben erwähnt, oder legen `allowPrototypes` auf `true` fest, wodurch diese Eigenschaften durch Benutzereingaben überschrieben werden können. *WARNUNG* Es ist im Allgemeinen keine gute Idee, diese Option zu aktivieren, da dies beim Versuch, die überschriebenen Eigenschaften zu verwenden, zu Problemen führen kann. Gehen Sie mit dieser Option immer vorsichtig um.

```javascript
var protoObject = qs.parse('a[hasOwnProperty]=b', { allowPrototypes: true });
assert.deepEqual(protoObject, { a: { hasOwnProperty: 'b' } });
```

URI-codierte Zeichenfolgen können auch zu Folgendem verwendet werden:

```javascript
assert.deepEqual(qs.parse('a%5Bb%5D=c'), {
    a: { b: 'c' }
});
```

Sie können Ihre Objekte auch schachteln, z. B `'foo[bar][baz]=foobarbaz'`:

```javascript
assert.deepEqual(qs.parse('foo[bar][baz]=foobarbaz'), {
    foo: {
        bar: {
            baz: 'foobarbaz'
        }
    }
});
```

Standardmäßig werden von **qs** beim Schachteln von Objekten nur bis zu 5 untergeordnete Elemente analysiert. Das bedeutet, dass aus dem Versuch, eine Zeichenfolge wie `'a[b][c][d][e][f][g][h][i]=j'` zu analysieren, das folgende Objekt resultiert:

```javascript
var expected = {
    a: {
        b: {
            c: {
                d: {
                    e: {
                        f: {
                            '[g][h][i]': 'j'
                        }
                    }
                }
            }
        }
    }
};
var string = 'a[b][c][d][e][f][g][h][i]=j';
assert.deepEqual(qs.parse(string), expected);
```

Diese Tiefe kann überschrieben werden, indem sie eine `depth`-Option an `qs.parse(string, [options])` übergeben:

```javascript
var deep = qs.parse('a[b][c][d][e][f][g][h][i]=j', { depth: 1 });
assert.deepEqual(deep, { a: { b: { '[c][d][e][f][g][h][i]': 'j' } } });
```

Die Tiefenbegrenzung hilft, bei Verwendung von **qs** zum Analysieren von Benutzereingaben Missbrauch zu verringern, und es wird empfohlen, es eine relativ niedrige Zahl beizubehalten.

Aus ähnlichen Gründen analysiert **qs** standardmäßig nur bis zu 1000 Parameter. Dies kann durch Übergeben einer `parameterLimit`-Option überschrieben werden:

```javascript
var limited = qs.parse('a=b&c=d', { parameterLimit: 1 });
assert.deepEqual(limited, { a: 'b' });
```

Um das führende Fragezeichen zu umgehen, verwenden Sie `ignoreQueryPrefix`:

```javascript
var prefixed = qs.parse('?a=b&c=d', { ignoreQueryPrefix: true });
assert.deepEqual(prefixed, { a: 'b', c: 'd' });
```

Es kann auch ein optionales Trennzeichen übergeben werden:

```javascript
var delimited = qs.parse('a=b;c=d', { delimiter: ';' });
assert.deepEqual(delimited, { a: 'b', c: 'd' });
```

Bei einem Trennzeichen kann es sich auch um einen regulären Ausdruck handeln:

```javascript
var regexed = qs.parse('a=b;c=d,e=f', { delimiter: /[;,]/ });
assert.deepEqual(regexed, { a: 'b', c: 'd', e: 'f' });
```

Option `allowDots` kann zum Aktivieren der Punktnotation verwendet werden:

```javascript
var withDots = qs.parse('a.b=c', { allowDots: true });
assert.deepEqual(withDots, { a: { b: 'c' } });
```

Wenn Sie es mit älteren Browsern oder Diensten zu tun haben, gibt es auch Unterstützung für die Decodierung von prozentcodierten Oktets als iso-8859-1:

```javascript
var oldCharset = qs.parse('a=%A7', { charset: 'iso-8859-1' });
assert.deepEqual(oldCharset, { a: '§' });
```

Einige Dienste fügen Formularen am Anfang einen `utf8=✓`-Wert hinzu, sodass alte Internet Explorer-Versionen das Formular mit größerer Wahrscheinlichkeit als utf-8 übermitteln. Darüber hinaus kann der Server den Wert auf falsche Codierungen des Häkchen-Zeichens überprüfen und erkennen, dass eine Abfragezeichenfolge oder `application/x-www-form-urlencoded`-Textkörper *nicht* als utf-8 gesendet wurde, z. B. wenn das Formular einen `accept-charset`-Parameter enthielt oder die enthaltende Seite einen anderen Zeichensatz aufwies.

**qs** unterstützt diesen Mechanismus über die `charsetSentinel`-Option.
Wird diese Option angegeben, wird der `utf8`-Parameter vom zurückgegebenen Objekt ausgelassen. Die Option wird verwendet, um in den `iso-8859-1`/`utf-8`-Modus zu wechseln, je nachdem, wie das Häkchen codiert ist.

**Wichtig:** Wenn Sie sowohl die Option `charset` als auch die Option `charsetSentinel` angeben, wird `charset` außer Kraft gesetzt, wenn die Anforderung einen `utf8`-Parameter enthält, aus dem der tatsächliche Zeichensatz abgeleitet werden kann. In diesem Sinne verhält sich `charset` wie der Standardzeichensatz und nicht wie der autoritative Zeichensatz.

```javascript
var detectedAsUtf8 = qs.parse('utf8=%E2%9C%93&a=%C3%B8', {
    charset: 'iso-8859-1',
    charsetSentinel: true
});
assert.deepEqual(detectedAsUtf8, { a: 'ø' });

// Browsers encode the checkmark as &#10003; when submitting as iso-8859-1:
var detectedAsIso8859_1 = qs.parse('utf8=%26%2310003%3B&a=%F8', {
    charset: 'utf-8',
    charsetSentinel: true
});
assert.deepEqual(detectedAsIso8859_1, { a: 'ø' });
```

Wenn Sie die `&#...;`-Syntax in das tatsächliche Zeichen decodieren möchten, können Sie auch die Option `interpretNumericEntities` angeben:

```javascript
var detectedAsIso8859_1 = qs.parse('a=%26%239786%3B', {
    charset: 'iso-8859-1',
    interpretNumericEntities: true
});
assert.deepEqual(detectedAsIso8859_1, { a: '☺' });
```

Das funktioniert auch, wenn der Zeichensatz im `charsetSentinel`-Modus erkannt wurde.

### <a name="parsing-arrays"></a>Analysieren von Arrays

**qs** kann mithilfe einer ähnlichen `[]`-Notation auch Arrays analysieren:

```javascript
var withArray = qs.parse('a[]=b&a[]=c');
assert.deepEqual(withArray, { a: ['b', 'c'] });
```

Sie können auch einen Index angeben:

```javascript
var withIndexes = qs.parse('a[1]=c&a[0]=b');
assert.deepEqual(withIndexes, { a: ['b', 'c'] });
```

Beachten Sie, dass der einzige Unterschied zwischen einem Index in einem Array und einem Schlüssel in einem Objekt darin besteht, dass der Wert zwischen den eckige Klammern eine Zahl sein muss, um ein Array zu erstellen. Beim Erstellen von Arrays mit bestimmten Indizes wird ein Sparsearray von **qs** nur in die vorhandenen Werte komprimiert, wobei ihre Reihenfolge beibehalten wird:

```javascript
var noSparse = qs.parse('a[1]=b&a[15]=c');
assert.deepEqual(noSparse, { a: ['b', 'c'] });
```

Sie können auch die Option `allowSparse` verwenden, um Sparsearrays zu analysieren:

```javascript
var sparseArray = qs.parse('a[1]=2&a[3]=5', { allowSparse: true });
assert.deepEqual(sparseArray, { a: [, '2', , '5'] });
```

Beachten Sie, dass eine leere Zeichenfolge auch ein Wert ist und beibehalten wird:

```javascript
var withEmptyString = qs.parse('a[]=&a[]=b');
assert.deepEqual(withEmptyString, { a: ['', 'b'] });

var withIndexedEmptyString = qs.parse('a[0]=b&a[1]=&a[2]=c');
assert.deepEqual(withIndexedEmptyString, { a: ['b', '', 'c'] });
```

**qs** beschränkt auch die Angabe von Indizes in einem Array auf einen maximalen Index von `20`. Alle Arrayelemente mit einem Index größer als `20` werden stattdessen in ein Objekt mit dem Index als Schlüssel konvertiert. Dies ist erforderlich, um Fälle zu behandeln, in denen jemand z. B. `a[999999999]` gesendet hat, und es eine erhebliche Zeit dauert, dieses riesige Array zu iterieren.

```javascript
var withMaxIndex = qs.parse('a[100]=b');
assert.deepEqual(withMaxIndex, { a: { '100': 'b' } });
```

Dieser Grenzwert kann durch Übergabe einer `arrayLimit`-Option überschrieben werden:

```javascript
var withArrayLimit = qs.parse('a[1]=b', { arrayLimit: 0 });
assert.deepEqual(withArrayLimit, { a: { '1': 'b' } });
```

Um die Arrayanalyse vollständig zu deaktivieren, legen Sie `parseArrays` auf `false` fest.

```javascript
var noParsingArrays = qs.parse('a[]=b', { parseArrays: false });
assert.deepEqual(noParsingArrays, { a: { '0': 'b' } });
```

Wenn Sie Notationen kombinieren, führt **qs** die beiden Elemente in ein Objekt zusammen:

```javascript
var mixedNotation = qs.parse('a[0]=b&a[b]=c');
assert.deepEqual(mixedNotation, { a: { '0': 'b', b: 'c' } });
```

Sie können auch Arrays von Objekten erstellen:

```javascript
var arraysOfObjects = qs.parse('a[][b]=c');
assert.deepEqual(arraysOfObjects, { a: [{ b: 'c' }] });
```

Einige Personen verbinden Arrays mit Kommas, **qs** kann sie analysieren:
```javascript
var arraysOfObjects = qs.parse('a=b,c', { comma: true })
assert.deepEqual(arraysOfObjects, { a: ['b', 'c'] })
```
(dadurch können keine geschachtelten Objekte, z. B. _`a={b:1},{c:d}` konvertiert werden_)

### <a name="stringifying"></a>Stringifizieren

[](#preventEval)
```javascript
qs.stringify(object, [options]);
```

Beim Stringifizieren wird die Ausgabe von **qs** standardmäßig URI-codiert. Objekte werden wie erwartet stringifiziert:

```javascript
assert.equal(qs.stringify({ a: 'b' }), 'a=b');
assert.equal(qs.stringify({ a: { b: 'c' } }), 'a%5Bb%5D=c');
```

Diese Codierung kann deaktiviert werden, indem die Option `encode` auf `false` festgelegt wird:

```javascript
var unencoded = qs.stringify({ a: { b: 'c' } }, { encode: false });
assert.equal(unencoded, 'a[b]=c');
```

Die Codierung kann für Schlüssel deaktiviert werden, indem die Option `encodeValuesOnly` auf `true` festgelegt wird:
```javascript
var encodedValues = qs.stringify(
    { a: 'b', c: ['d', 'e=f'], f: [['g'], ['h']] },
    { encodeValuesOnly: true }
);
assert.equal(encodedValues,'a=b&c[0]=d&c[1]=e%3Df&f[0][0]=g&f[1][0]=h');
```

Diese Codierung kann auch durch eine benutzerdefinierte Codierungsmethode ersetzt werden, die als `encoder`-Option festgelegt ist:

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str) {
    // Passed in values `a`, `b`, `c`
    return // Return encoded string
}})
```

_(Hinweis: Die Option `encoder` gilt nicht, wenn `encode` den Wert `false` aufweist.)_

Analog zu `encoder` gibt es eine `decoder`-Option für `parse` zum Außerkraftsetzen der Decodierung von Eigenschaften und Werten:

```javascript
var decoded = qs.parse('x=z', { decoder: function (str) {
    // Passed in values `x`, `z`
    return // Return decoded string
}})
```

Sie können Schlüssel und Werte mit unterschiedlicher Logik codieren, indem Sie das Typargument verwenden, das dem Encoder bereitgestellt wird:

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str, defaultEncoder, charset, type) {
    if (type === 'key') {
        return // Encoded key
    } else if (type === 'value') {
        return // Encoded value
    }
}})
```

Das Typargument wird auch für den Decoder bereitgestellt:

```javascript
var decoded = qs.parse('x=z', { decoder: function (str, defaultDecoder, charset, type) {
    if (type === 'key') {
        return // Decoded key
    } else if (type === 'value') {
        return // Decoded value
    }
}})
```

Beispiele, die über diesen Punkt hinausgehen, werden der Übersichtlichkeit halber so dargestellt, als ob die Ausgabe nicht URI-codiert wäre. Beachten Sie, dass die Rückgabewerte in diesen Fällen bei der tatsächlichen Verwendung dennoch *URI-codiert sind*.

Wenn Arrays stringifiziert sind, erhalten sie standardmäßig explizite Indizes:

```javascript
qs.stringify({ a: ['b', 'c', 'd'] });
// 'a[0]=b&a[1]=c&a[2]=d'
```

Sie können dies außer Kraft setzen, indem Sie die `indices`-Option auf `false` festlegen:

```javascript
qs.stringify({ a: ['b', 'c', 'd'] }, { indices: false });
// 'a=b&a=c&a=d'
```

Sie können die Option `arrayFormat` verwenden, um das Format des Ausgabearrays anzugeben:

```javascript
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'indices' })
// 'a[0]=b&a[1]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'brackets' })
// 'a[]=b&a[]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'repeat' })
// 'a=b&a=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'comma' })
// 'a=b,c'
```

Wenn Objekte stringifiziert werden, verwenden sie standardmäßig die Klammernotation:

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } });
// 'a[b][c]=d&a[b][e]=f'
```

Sie können dies außer Kraft setzen, indem Sie die Option `allowDots` auf `true` festlegen, um die Punktnotation zu verwenden:

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } }, { allowDots: true });
// 'a.b.c=d&a.b.e=f'
```

Bei leeren Zeichenfolgen und NULL-Werten wird der Wert ausgelassen, aber das Gleichheitszeichen (=) bleibt an seinem Platz:

```javascript
assert.equal(qs.stringify({ a: '' }), 'a=');
```

Schlüssel ohne Werte (z. B. ein leeres Objekt oder ein leerer Array) geben nichts zurück:

```javascript
assert.equal(qs.stringify({ a: [] }), '');
assert.equal(qs.stringify({ a: {} }), '');
assert.equal(qs.stringify({ a: [{}] }), '');
assert.equal(qs.stringify({ a: { b: []} }), '');
assert.equal(qs.stringify({ a: { b: {}} }), '');
```

Eigenschaften, die auf `undefined` festgelegt sind, werden vollständig ausgelassen:

```javascript
assert.equal(qs.stringify({ a: null, b: undefined }), 'a=');
```

Der Abfragezeichenfolge kann optional ein Fragezeichen vorangestellt werden:

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { addQueryPrefix: true }), '?a=b&c=d');
```

Das Trennzeichen kann auch mit „stringify“ überschrieben werden:

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { delimiter: ';' }), 'a=b;c=d');
```

Wenn Sie nur die Serialisierung von `Date`-Objekten außer Kraft setzen möchten, können Sie eine `serializeDate`-Option bereitstellen:

```javascript
var date = new Date(7);
assert.equal(qs.stringify({ a: date }), 'a=1970-01-01T00:00:00.007Z'.replace(/:/g, '%3A'));
assert.equal(
    qs.stringify({ a: date }, { serializeDate: function (d) { return d.getTime(); } }),
    'a=7'
);
```

Sie können die Option `sort` verwenden, um die Reihenfolge der Parameterschlüssel zu beeinflussen:

```javascript
function alphabeticalSort(a, b) {
    return a.localeCompare(b);
}
assert.equal(qs.stringify({ a: 'c', z: 'y', b : 'f' }, { sort: alphabeticalSort }), 'a=c&b=f&z=y');
```

Schließlich können Sie die Option `filter` verwenden, um einzuschränken, welche Schlüssel in die stringifizierte Ausgabe einbezogen werden.
Wenn Sie eine Funktion übergeben, wird sie für jeden Schlüssel aufgerufen, um den Ersatzwert abzurufen. Wenn Sie hingegen ein Array übergeben, wird es verwendet, um Eigenschaften und Arrayindizes für die Stringifizierung auszuwählen:

```javascript
function filterFunc(prefix, value) {
    if (prefix == 'b') {
        // Return an `undefined` value to omit a property.
        return;
    }
    if (prefix == 'e[f]') {
        return value.getTime();
    }
    if (prefix == 'e[g][0]') {
        return value * 2;
    }
    return value;
}
qs.stringify({ a: 'b', c: 'd', e: { f: new Date(123), g: [2] } }, { filter: filterFunc });
// 'a=b&c=d&e[f]=123&e[g][0]=4'
qs.stringify({ a: 'b', c: 'd', e: 'f' }, { filter: ['a', 'e'] });
// 'a=b&e=f'
qs.stringify({ a: ['b', 'c', 'd'], e: 'f' }, { filter: ['a', 0, 2] });
// 'a[0]=b&a[2]=d'
```

### <a name="handling-of-null-values"></a>Behandeln von `null`-Werten

Standardmäßig werden `null`-Werte wie leere Zeichenfolgen behandelt:

```javascript
var withNull = qs.stringify({ a: null, b: '' });
assert.equal(withNull, 'a=&b=');
```

Die Analyse unterscheidet nicht zwischen Parametern mit und ohne Gleichheitszeichen. Beide werden in leere Zeichenfolgen konvertiert.

```javascript
var equalsInsensitive = qs.parse('a&b=');
assert.deepEqual(equalsInsensitive, { a: '', b: '' });
```

Um zwischen `null`-Werten und leeren Zeichenfolgen zu unterscheiden, verwenden Sie das Flag `strictNullHandling`. In der Ergebniszeichenfolge weisen die `null`-Werte kein `=`-Zeichen auf:

```javascript
var strictNull = qs.stringify({ a: null, b: '' }, { strictNullHandling: true });
assert.equal(strictNull, 'a&b=');
```

Um Werte ohne `=` zurück in `null` zu analysieren, verwenden Sie das Flag `strictNullHandling`:

```javascript
var parsedStrictNull = qs.parse('a&b=', { strictNullHandling: true });
assert.deepEqual(parsedStrictNull, { a: null, b: '' });
```

Verwenden Sie zum vollständigen Überspringen von Renderingschlüsseln mit `null`-Werten das Flag `skipNulls`:

```javascript
var nullsSkipped = qs.stringify({ a: 'b', c: null}, { skipNulls: true });
assert.equal(nullsSkipped, 'a=b');
```

Wenn Sie mit Legacysystemen kommunizieren, können Sie mit der Option `charset` zurück zu `iso-8859-1` wechseln:

```javascript
var iso = qs.stringify({ æ: 'æ' }, { charset: 'iso-8859-1' });
assert.equal(iso, '%E6=%E6');
```

Zeichen, die in `iso-8859-1` nicht vorhanden sind, werden in numerische Entitäten konvertiert, ähnlich wie in Browsern:

```javascript
var numeric = qs.stringify({ a: '☺' }, { charset: 'iso-8859-1' });
assert.equal(numeric, 'a=%26%239786%3B');
```

Sie können die Option `charsetSentinel` verwenden, um das Zeichen anzukündigen, indem Sie einen `utf8=✓`-Parameter mit der richtigen Codierung einfügen, wenn das Häkchen gesetzt ist, ähnlich wie es Ruby on Rails und andere bei der Übermittlung von Formularen tun.

```javascript
var sentinel = qs.stringify({ a: '☺' }, { charsetSentinel: true });
assert.equal(sentinel, 'utf8=%E2%9C%93&a=%E2%98%BA');

var isoSentinel = qs.stringify({ a: 'æ' }, { charsetSentinel: true, charset: 'iso-8859-1' });
assert.equal(isoSentinel, 'utf8=%26%2310003%3B&a=%E6');
```

### <a name="dealing-with-special-character-sets"></a>Umgang mit Sonderzeichensätzen

Standardmäßig erfolgt die Codierung und Decodierung von Zeichen in `utf-8`, und `iso-8859-1`-Unterstützung wird ebenfalls über den Parameter `charset` integriert.

Wenn Sie Abfragezeichenfolgen in einen anderen Zeichensatz codieren möchten (d. h. [Shift JIS](https://en.wikipedia.org/wiki/Shift_JIS)), können Sie die [`qs-iconv`](https://github.com/martinheidegger/qs-iconv)-Bibliothek verwenden:

```javascript
var encoder = require('qs-iconv/encoder')('shift_jis');
var shiftJISEncoded = qs.stringify({ a: 'こんにちは！' }, { encoder: encoder });
assert.equal(shiftJISEncoded, 'a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I');
```

Dies funktioniert auch für die Decodierung von Abfragezeichenfolgen:

```javascript
var decoder = require('qs-iconv/decoder')('shift_jis');
var obj = qs.parse('a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I', { decoder: decoder });
assert.deepEqual(obj, { a: 'こんにちは！' });
```

### <a name="rfc-3986-and-rfc-1738-space-encoding"></a>RFC 3986- und RFC 1738-Raumcodierung

RFC3986 wird als Standardoption verwendet und codiert ' ' in *%20*, was abwärtskompatibel ist.
Gleichzeitig kann die Ausgabe per RFC1738 mit ' ' gleich '+' stringifiziert werden.

```
assert.equal(qs.stringify({ a: 'b c' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC3986' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC1738' }), 'a=b+c');
```

## <a name="security"></a>Sicherheit

Senden Sie eine E-Mail an [@ljharb](https://github.com/ljharb), oder sehen Sie unter https://tidelift.com/security nach, wenn Sie ein potenzielles Sicherheitsrisiko zu melden haben.

## <a name="qs-for-enterprise"></a>qs für Unternehmen

Verfügbar im Rahmen des Tidelift-Abonnements

Die Maintainer von qs und Tausender anderer Pakete arbeiten mit Tidelift, um kommerzielle Unterstützung und Wartung für die Open Source-Abhängigkeiten bereitzustellen, die Sie zum Erstellen Ihrer Anwendungen nutzen. Sparen Sie Zeit, reduzieren Sie Risiken und verbessern Sie die Codeintegrität, während Sie die Maintainer der speziellen von Ihnen verwendeten Abhängigkeiten bezahlen. [Weitere Informationen.](https://tidelift.com/subscription/pkg/npm-qs?utm_source=npm-qs&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)

[1]: https://npmjs.org/package/qs
[2]: http://versionbadg.es/ljharb/qs.svg
[3]: https://api.travis-ci.org/ljharb/qs.svg
[4]: https://travis-ci.org/ljharb/qs
[5]: https://david-dm.org/ljharb/qs.svg
[6]: https://david-dm.org/ljharb/qs
[7]: https://david-dm.org/ljharb/qs/dev-status.svg
[8]: https://david-dm.org/ljharb/qs?type=dev
[9]: https://ci.testling.com/ljharb/qs.png
[10]: https://ci.testling.com/ljharb/qs
[11]: https://nodei.co/npm/qs.png?downloads=true&stars=true
[license-image]: http://img.shields.io/npm/l/qs.svg
[license-url]: LICENSE
[downloads-image]: http://img.shields.io/npm/dm/qs.svg
[downloads-url]: http://npm-stat.com/charts.html?package=qs
