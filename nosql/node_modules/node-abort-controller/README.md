---
ms.openlocfilehash: ca2cf748b426d17058b55202a60ece01d9e05592
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051456"
---
# <a name="node-abort-controller"></a>node-abort-controller

AbortController-Polyfill für Node.JS, basierend auf EventEmitter

[![Buildstatus](https://dev.azure.com/stfaul/node-abort-controller/_apis/build/status/southpolesteve.node-abort-controller?branchName=master)](https://dev.azure.com/stfaul/node-abort-controller/_build/latest?definitionId=3&branchName=master)

## <a name="usage"></a>Verbrauch

```js
import fetch from 'node-fetch'
import AbortController from 'node-abort-controller'

const controller = new AbortController()
const signal = controller.signal

await fetch('https:/www.google.com', { signal })

// Abort after 500ms. Effectively a timeout
setTimeout(() => controller.abort(), 500)
```

## <a name="why-would-i-use-this"></a>Warum sollte ich das verwenden?

Möglicherweise müssen Sie es nicht! Im Allgemeinen gibt es drei Umgebungen, in denen Ihr JavaScript-Code ausgeführt werden kann:

- Node
- Moderne Browser (nicht Internet Explorer)
- Legacy-Browser (hauptsächlich Internet Explorer)

Für moderne JS-APIs erhielte jede Umgebung idealerweise ein Polyfill:

- nur, wenn eins benötigt wird
- spezifisch für die Plattform.

In der Praxis ist dies schwer. Tools wie webpack und browserify sind großartig, um sicherzustellen, dass Dinge vorgefertigt sofort in allen Umgebungen funktionieren. Aber es ist recht einfach, bei beiden vorgenannten Punkten zu versagen. Höchstwahrscheinlich werden Sie am Ende weniger als ideale Polyfills auf Plattformen ausliefern, die sie gar nicht benötigen. Was muss ein Entwickler also tun? Im Fall `fetch` von und `AbortController` habe ich die Arbeit für Sie erledigt. Dies ist ein Leitfaden für diese Arbeit.

Wenn Sie Folgendes erstellen...

#### <a name="application-running-in-modern-browsers"></a>Anwendung, die in modernen Browsern ausgeführt wird:

Glückwunsch! Sie benötigen weder eine Bibliothek noch ein Polyfill! Schließen Sie diese Registerkarte. Deinstallieren Sie dieses Paket.

#### <a name="application-running-in-modern-browsers-and-node-such-as-a-server-side-rendered-js-app"></a>Anwendung, die in modernen Browsern UND Node ausgeführt wird (z. B. eine serverseitig gerenderte JS-App):

Verwenden Sie _dieses Paket_ und [node-fetch](https://www.npmjs.com/package/node-fetch). Das ist das Minimum, was Sie benötigen.

#### <a name="application-supporting-legacy-browsers-and-not-node"></a>Anwendung, die Legacy-Browser unterstützt UND NICHT Node:

Verwenden Sie [abort-controller](https://www.npmjs.com/package/abort-controller) und [whatwg-fetch](https://www.npmjs.com/package/whatwg-fetch). Dies sind vollständigere Polyfills, die in allen Browserumgebungen funktionieren.

#### <a name="application-supporting-legacy-browsers-and-node"></a>Anwendung, die ältere Browser UND Node unterstützt:

Verwenden Sie [abort-controller](https://www.npmjs.com/package/abort-controller) und [cross-fetch](https://www.npmjs.com/package/cross-fetch). Dasselbe wie oben, mit der Ausnahme, dass cross-fetch sowohl im Browser als auch in Node.js ein korrektes Polyfill ist.

#### <a name="library-being-consumed-by-other-applications-and-using-fetch-internally"></a>Bibliothek, die von anderen Anwendungen verwendet wird und intern `fetch` verwendet:

Verwenden Sie _dieses Paket_ und [node-fetch](https://www.npmjs.com/package/node-fetch). Dies ist die kleinste und am wenigsten dogmatische Kombination für Ihre Endbenutzer. Anwendungsentwickler, die für Internet Explorer entwickeln, müssen für `AbortController` und `fetch` selbständig Polyfills entwickeln. Ihre Bibliothek erzwingt aber keine unnötigen Polyfills bei Entwicklern, die nur für moderne Browser entwickeln.

## <a name="goals"></a>Ziele

Mit dem obigen Leitfaden im Hinterkopf hat diese Bibliothek eine sehr spezifische Gruppe von Zielen:

1. Bereitstellen eines minimalen Polyfills in Node.js
2. Keine Bereitstellung von Polyfills in einer Browserumgebung

Dies ist die ideale Lösung für _Bibliotheksautoren_, die sowohl `fetch` als auch `AbortController` intern verwenden und auf _beide_ abzielen, Browser- und Node-Entwickler.

## <a name="prior-art"></a>Stand der Technik

Vielen Dank @mysticatea für https://github.com/mysticatea/abort-controller. Es ist ein fantastisches `AbortController`-Polyfill und ideal für viele Anwendungsfälle geeignet.
