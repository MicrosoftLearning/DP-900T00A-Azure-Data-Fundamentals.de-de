---
ms.openlocfilehash: f9f95f626a5d55dca7937d56df8b3dd3b7040164
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051384"
---
# <a name="bl-bufferlist"></a>bl *(BufferList)*

[![Buildstatus](https://api.travis-ci.com/rvagg/bl.svg?branch=master)](https://travis-ci.com/rvagg/bl/)

**Ein Node.js-Pufferlistensammler-, Leser- und Streamer-Objekt.**

[![NPM](https://nodei.co/npm/bl.svg)](https://nodei.co/npm/bl/)

**bl** ist ein Speicherobjekt für Sammlungen von Node-Puffern, das sie mit der pufferlesbaren Haupt-API verfügbar macht. Funktioniert auch als Duplexstream, sodass Sie Puffer aus einem ausgebenden Stream sammeln und an einen verbrauchenden Stream ausgeben können.

Die Originalpuffer bleiben intakt, und Kopien werden nur nach Bedarf durchgeführt. Alle Lesevorgänge, die die Verwendung eines einzelnen Originalpuffers erfordern, geben nur einen Datenschnitt dieses Puffers zurück (der auf denselben Speicher wie der Originalpuffer verweist). Lesevorgänge, die Puffer umfassen, führen bei Bedarf Verkettungen durch und geben die Ergebnisse transparent zurück.

```js
const { BufferList } = require('bl')

const bl = new BufferList()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append('hi')                     // bl will also accept & convert Strings
bl.append(Buffer.from('j'))
bl.append(Buffer.from([ 0x3, 0x4 ]))

console.log(bl.length) // 12

console.log(bl.slice(0, 10).toString('ascii')) // 'abcdefghij'
console.log(bl.slice(3, 10).toString('ascii')) // 'defghij'
console.log(bl.slice(3, 6).toString('ascii'))  // 'def'
console.log(bl.slice(3, 8).toString('ascii'))  // 'defgh'
console.log(bl.slice(5, 10).toString('ascii')) // 'fghij'

console.log(bl.indexOf('def')) // 3
console.log(bl.indexOf('asdf')) // -1

// or just use toString!
console.log(bl.toString())               // 'abcdefghij\u0003\u0004'
console.log(bl.toString('ascii', 3, 8))  // 'defgh'
console.log(bl.toString('ascii', 5, 10)) // 'fghij'

// other standard Buffer readables
console.log(bl.readUInt16BE(10)) // 0x0304
console.log(bl.readUInt16LE(10)) // 0x0403
```

Legen Sie einen Rückruf im Konstruktor fest, und verwenden Sie ihn genauso wie **[concat-stream](https://github.com/maxogden/node-concat-stream)**:

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

fs.createReadStream('README.md')
  .pipe(BufferListStream((err, data) => { // note 'new' isn't strictly required
    // `data` is a complete Buffer object containing the full data
    console.log(data.toString())
  }))
```

Beachten Sie, dass bei Verwendung einer *callback*-Methode wie dieser der resultierende `data`-Parameter eine Verkettung aller `Buffer`-Objekte in der Liste ist. Wenn Sie den Mehraufwand dieser Verkettung (in Fällen extremer Leistungsanforderungen) vermeiden möchten, verwenden Sie die *callback*-Methode nicht, und lauschen Sie stattdessen wie ein Standardstream dem `'end'`-Objekt.

Alternative: Um eine URL mithilfe von [hyperquest](https://github.com/substack/hyperquest) abzurufen (sollte mit [request](http://github.com/mikeal/request) und sogar reinem Node-HTTP funktionieren):

```js
const hyperquest = require('hyperquest')
const { BufferListStream } = require('bl')

const url = 'https://raw.github.com/rvagg/bl/master/README.md'

hyperquest(url).pipe(BufferListStream((err, data) => {
  console.log(data.toString())
}))
```

Oder verwenden Sie ihn als lesbaren Stream, um eine Liste von Puffern an einer Ausgabequelle neu zusammenzusetzen:

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

var bl = new BufferListStream()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append(Buffer.from('hi'))
bl.append(Buffer.from('j'))

bl.pipe(fs.createWriteStream('gibberish.txt'))
```

## <a name="api"></a>API

  * <a href="#ctor"><code><b>new BufferList([ buf ])</b></code></a>
  * <a href="#isBufferList"><code><b>BufferList.isBufferList(obj)</b></code></a>
  * <a href="#length"><code>bl.<b>length</b></code></a>
  * <a href="#append"><code>bl.<b>append(buffer)</b></code></a>
  * <a href="#get"><code>bl.<b>get(index)</b></code></a>
  * <a href="#indexOf"><code>bl.<b>indexOf(value[, byteOffset][, encoding])</b></code></a>
  * <a href="#slice"><code>bl.<b>slice([ start[, end ] ])</b></code></a>
  * <a href="#shallowSlice"><code>bl.<b>shallowSlice([ start[, end ] ])</b></code></a>
  * <a href="#copy"><code>bl.<b>copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])</b></code></a>
  * <a href="#duplicate"><code>bl.<b>duplicate()</b></code></a>
  * <a href="#consume"><code>bl.<b>consume(bytes)</b></code></a>
  * <a href="#toString"><code>bl.<b>toString([encoding, [ start, [ end ]]])</b></code></a>
  * <a href="#readXX"><code>bl.<b>readDoubleBE()</b></code>, <code>bl.<b>readDoubleLE()</b></code>, <code>bl.<b>readFloatBE()</b></code>, <code>bl.<b>readFloatLE()</b></code>, <code>bl.<b>readInt32BE()</b></code>, <code>bl.<b>readInt32LE()</b></code>, <code>bl.<b>readUInt32BE()</b></code>, <code>bl.<b>readUInt32LE()</b></code>, <code>bl.<b>readInt16BE()</b></code>, <code>bl.<b>readInt16LE()</b></code>, <code>bl.<b>readUInt16BE()</b></code>, <code>bl.<b>readUInt16LE()</b></code>, <code>bl.<b>readInt8()</b></code>, <code>bl.<b>readUInt8()</b></code></a>
  * <a href="#ctorStream"><code><b>new BufferListStream([ callback ])</b></code></a>

--------------------------------------------------------
<a name="ctor"></a>
### <a name="new-bufferlist-buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferList([ Buffer | Buffer array | BufferList | BufferList array | String ])
Es sind keine Argumente für den Konstruktor _erforderlich_, aber Sie können die Liste initialisieren, indem Sie ein einzelnes `Buffer`-Objekt oder ein Array von `Buffer`-Objekten übergeben.

`new` ist nicht unbedingt erforderlich. Wenn Sie kein neues Objekt instanziieren, wird dies automatisch für Sie ausgeführt. Daher können Sie eine neue Instanz einfach mit folgendem Code erstellen:

```js
const { BufferList } = require('bl')
const bl = BufferList()

// equivalent to:

const { BufferList } = require('bl')
const bl = new BufferList()
```

--------------------------------------------------------
<a name="isBufferList"></a>
### <a name="bufferlistisbufferlistobj"></a>BufferList.isBufferList(obj)
Bestimmt, ob es sich bei dem übergebenen Objekt um ein `BufferList` handelt. `true` wird zurückgegeben, wenn es sich bei dem übergebenen Objekt um eine Instanz von `BufferList` handelt, **oder** andernfalls `BufferListStream` und `false`.

N.B. Dabei wird für `BufferList`- oder `BufferListStream`-Instanzen, die von Versionen dieser Bibliothek vor Hinzufügen dieser statischen Methode erstellt wurden, nicht `true` zurückgegeben.

--------------------------------------------------------
<a name="length"></a>
### <a name="bllength"></a>bl.length
Abrufen der Länge der Liste in Bytes. Dies ist die Summe der Längen aller Puffer, die in der Liste enthalten sind, minus aller anfänglichen Offsets für einen halb verbrauchten Puffer am Anfang. Sollte die Gesamtzahl der Bytes, die aus der Liste gelesen werden können, exakt darstellen.

--------------------------------------------------------
<a name="append"></a>
### <a name="blappendbuffer--buffer-array--bufferlist--bufferlist-array--string"></a>bl.append(Buffer | Buffer array | BufferList | BufferList array | String)
`append(buffer)` fügt der internen Liste einen zusätzlichen Puffer oder ein BufferList-Objekt hinzu. `this` wird zurückgegeben, sodass eine Verkettung vorgenommen werden kann.

--------------------------------------------------------
<a name="get"></a>
### <a name="blgetindex"></a>bl.get(index)
`get()` gibt das Byte am angegebenen Index zurück.

--------------------------------------------------------
<a name="indexOf"></a>
### <a name="blindexofvalue-byteoffset-encoding"></a>bl.indexOf(value[, byteOffset][, encoding])
`get()` gibt das Byte am angegebenen Index zurück.
Die `indexOf()`-Methode gibt den ersten Index zurück, bei dem ein bestimmtes Element im BufferList-Objekt gefunden wird, oder „-1“, wenn es nicht vorhanden ist.

--------------------------------------------------------
<a name="slice"></a>
### <a name="blslice-start--end--"></a>bl.slice([ start, [ end ] ])
`slice()` gibt ein neues `Buffer`-Objekt zurück, das die Bytes innerhalb des angegebenen Bereichs enthält. Sowohl `start` als auch `end` sind optional und werden standardmäßig auf den Anfang und das Ende der Liste festgelegt.

Wenn der angeforderte Bereich einen einzelnen internen Puffer umfasst, wird ein Datenschnitt dieses Puffers zurückgegeben, der den ursprünglichen Speicherbereich dieses Puffers teilt. Wenn sich der Bereich über mehrere Puffer erstreckt, treten wahrscheinlich Kopiervorgänge auf, um Ihnen einen einheitlichen Puffer bereitzustellen.

--------------------------------------------------------
<a name="shallowSlice"></a>
### <a name="blshallowslice-start--end--"></a>bl.shallowSlice([ start, [ end ] ])
`shallowSlice()` gibt ein neues `BufferList`-Objekt zurück, das die Bytes innerhalb des angegebenen Bereichs enthält. Sowohl `start` als auch `end` sind optional und werden standardmäßig auf den Anfang und das Ende der Liste festgelegt.

Es werden keine Kopiervorgänge ausgeführt. Alle Puffer im Arbeitsspeicher der Ergebnisfreigabe mit der ursprünglichen Liste.

--------------------------------------------------------
<a name="copy"></a>
### <a name="blcopydest--deststart--srcstart--srcend---"></a>bl.copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])
`copy()` kopiert den Inhalt der Liste im `dest`-Puffer, beginnend von `destStart`, und enthält die Bytes innerhalb des angegebenen Bereichs von `srcStart` bis `srcEnd`. `destStart`, `start` und `end` sind optional und werden standardmäßig auf den Anfang und das Ende des `dest`-Puffers bzw. den Anfang und das Ende der Liste festgelegt.

--------------------------------------------------------
<a name="duplicate"></a>
### <a name="blduplicate"></a>bl.duplicate()
`duplicate()` führt einen **shallow-copy**-Vorgang für die Liste aus. Die internen Puffer bleiben unverändert. Wenn Sie also die zugrunde liegenden Puffer ändern, spiegelt sich die Änderung sowohl im Original als auch im Duplikat wider. Diese Methode ist erforderlich, wenn Sie `consume()` oder `pipe()` aufrufen und dennoch die ursprüngliche Liste beibehalten möchten. Beispiel:

```js
var bl = new BufferListStream()

bl.append('hello')
bl.append(' world')
bl.append('\n')

bl.duplicate().pipe(process.stdout, { end: false })

console.log(bl.toString())
```

--------------------------------------------------------
<a name="consume"></a>
### <a name="blconsumebytes"></a>bl.consume(bytes)
`consume()` verschiebt Bytes *weg vom Anfang der Liste*. Die Anzahl der verbrauchten Bytes muss nicht mit den Größen der internen Puffer übereinstimmen&mdash;Die ursprünglichen Offsets werden entsprechend berechnet, um Ihnen eine konsistente Sicht der Daten bereitzustellen.

--------------------------------------------------------
<a name="toString"></a>
### <a name="bltostringencoding--start--end-"></a>bl.toString([encoding, [ start, [ end ]]])
`toString()` gibt eine Zeichenfolgendarstellung des Puffers zurück. Die optionalen Argumente `start` und `end` werden an `slice()` übergeben, während `encoding` an das `toString()`-Objekt des resultierenden Puffers übergeben wird. Weitere Informationen finden Sie in der Dokumentation zu [Buffer#toString()](http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end).

--------------------------------------------------------
<a name="readXX"></a>
### <a name="blreaddoublebe-blreaddoublele-blreadfloatbe-blreadfloatle-blreadint32be-blreadint32le-blreaduint32be-blreaduint32le-blreadint16be-blreadint16le-blreaduint16be-blreaduint16le-blreadint8-blreaduint8"></a>bl.readDoubleBE(), bl.readDoubleLE(), bl.readFloatBE(), bl.readFloatLE(), bl.readInt32BE(), bl.readInt32LE(), bl.readUInt32BE(), bl.readUInt32LE(), bl.readInt16BE(), bl.readInt16LE(), bl.readUInt16BE(), bl.readUInt16LE(), bl.readInt8(), bl.readUInt8()

Alle standardmäßigen Bytelesemethoden der `Buffer`-Schnittstelle werden implementiert und transparent über interne Puffergrenzen hinweg ausgeführt.

Wie diese funktionieren, ist in der <b><code>[Buffer](http://nodejs.org/docs/latest/api/buffer.html)</code></b>-Dokumentation beschrieben.

--------------------------------------------------------
<a name="ctorStream"></a>
### <a name="new-bufferliststream-callback--buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferListStream([ callback | Buffer | Buffer array | BufferList | BufferList array | String ])
**BufferListStream** ist ein Node-**[Duplexstream](http://nodejs.org/docs/latest/api/stream.html#stream_class_stream_duplex)**, aus dem gelesen und in den geschrieben werden kann, wie bei Node-Standardstreams. Sie können auch `pipe()` zu und aus einer **BufferListStream**-Instanz verwenden.

Der Konstruktor verwendet einen optionalen Rückruf, der, sofern angegeben, mit einem Fehlerargument aufgerufen wird, gefolgt von einem Verweis auf die **bl**-Instanz, wenn `bl.end()` aufgerufen wird (z. B. aus einem weitergeleiteten Stream). Dies ist eine bequeme Methode zum Sammeln des gesamten Inhalts eines Streams, insbesondere, wenn der Stream *segmentiert* ist, z. B. ein Netzwerkdatenstrom.

Es sind normalerweise keine Argumente für den Konstruktor erforderlich, aber Sie können die Liste initialisieren, indem Sie ein einzelnes `Buffer`-Objekt oder ein Array des `Buffer`-Objekts übergeben.

`new` ist nicht unbedingt erforderlich. Wenn Sie kein neues Objekt instanziieren, wird dies automatisch für Sie ausgeführt. Daher können Sie eine neue Instanz einfach mit folgendem Code erstellen:

```js
const { BufferListStream } = require('bl')
const bl = BufferListStream()

// equivalent to:

const { BufferListStream } = require('bl')
const bl = new BufferListStream()
```

N.B. Aus Gründen der Abwärtskompatibilität ist `BufferListStream` der **Standardexport**, wenn Sie `require('bl')` verwenden:

```js
const { BufferListStream } = require('bl')
// equivalent to:
const BufferListStream = require('bl')
```

--------------------------------------------------------

## <a name="contributors"></a>Beitragende

**bl** wird Ihnen von den folgenden Hackern zur Verfügung gestellt:

 * [Rod Vagg](https://github.com/rvagg)
 * [Matteo Collina](https://github.com/mcollina)
 * [Jarett Cruger](https://github.com/jcrugzz)

<a name="license"></a>
## <a name="license-amp-copyright"></a>Lizenz &amp; Copyright

Copyright (c) 2013-2019 bl-Mitwirkende (oben aufgeführt).

bl ist unter der MIT-Lizenz lizenziert. Alle nicht explizit in der MIT-Lizenz gewährten Rechte vorbehalten. Weitere Informationen finden Sie in der enthaltenen LICENSE.md-Datei.
