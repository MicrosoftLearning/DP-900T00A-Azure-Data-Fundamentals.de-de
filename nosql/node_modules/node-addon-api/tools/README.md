---
ms.openlocfilehash: 3decbdeed6f0c742925a5be9b78f5251a4c0b569
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051207"
---
# <a name="tools"></a>Tools

## <a name="clang-format"></a>Clang-Format

Die Clang-Formatprüfungstools sind so konzipiert, dass geänderte Codezeilen im Vergleich zu bestimmten Git-Refs überprüft werden.

## <a name="migration-script"></a>Migrationsskript

Das Migrationstool ist so konzipiert, dass Tätigkeiten im Migrationsprozess nicht mehr so oft wiederholt werden müssen. Das Skript zielt jedoch nicht darauf ab, alles für Sie zu konvertieren. In der Regel sind einige kleine Korrekturen und große Wiederherstellungen erforderlich.

### <a name="how-to-use"></a>Verwendung

Um das Konvertierungsskript auszuführen, stellen Sie zunächst sicher, dass Sie über das neueste `node-addon-api` in Ihrem `node_modules`-Verzeichnis verfügen.
```
npm install node-addon-api
```

Führen Sie dann das Skript aus dem Projektverzeichnis auf.
```
node ./node_modules/node-addon-api/tools/conversion.js ./
```

Anschließend müssen Sie alles, was das Skript verpasst hat, erneut kompilieren und debuggen.


### <a name="quick-fixes"></a>Schnelle Problembehandlung
Hier sehen Sie eine Liste der Dinge, die leicht behoben werden können.
  1. Ändern Sie den Rückgabewert Ihrer Methoden in void, wenn der Wert nicht in JavaScript zurückgegeben wird.
  2. Verwenden Sie `.`, um auf das Attribut zuzugreifen und um die Memberfunktion in Napi::Object anstelle von `->` aufzurufen.
  3. `Napi::New(env, value);` zu `Napi::[Type]::New(env, value);


### <a name="major-reconstructions"></a>Größere Rekonstruktionen
Die Implementierung von `Napi::ObjectWrap` unterscheidet sich deutlich von der NAN-Implementierung. `Napi::ObjectWrap` zeigt auf das umschlossene Objekt und erstellt einen Verweis auf das umschlossene Objekt innerhalb des ObjectWrap-Konstruktors. Darüber hinaus ordnet `Napi::ObjectWrap` die Instanzmethoden des umschlossenen Objekts außerdem dem Javascript-Modul zu anstatt statische Methoden wie NAN anzuwenden.

Wenn Sie also Nan::ObjectWrap in Ihrem Modul verwenden, müssen Sie die folgenden Schritte ausführen.

  1. Konvertieren Sie Ihre Funktion [ClassName]::New in eine Konstruktorfunktion, die eine `Napi::CallbackInfo` benötigt. Deklarieren Sie sie als
```
[ClassName](const Napi::CallbackInfo& info);
```
und definieren Sie sie als
```
[ClassName]::[ClassName](const Napi::CallbackInfo& info) : Napi::ObjectWrap<[ClassName]>(info){
  ...
}
```
Auf diese Weise wird der `Napi::ObjectWrap`-Konstruktor aufgerufen, nachdem das Objekt instanziiert wurde, und `Napi::ObjectWrap` kann mit dem `this`-Zeiger einen Verweis auf das umschlossene Objekt erstellen.

  2. Verschieben Sie den ursprünglichen Konstruktorcode in den neuen Konstruktor. Löschen Sie Ihren ursprünglichen Konstruktor.
  3. Ordnen Sie in Ihrer Klasseninitialisierungsfunktion native Methoden wie folgt zu.
```
Napi::FunctionReference constructor;

void [ClassName]::Init(Napi::Env env, Napi::Object exports, Napi::Object module) {
  Napi::HandleScope scope(env);
  Napi::Function ctor = DefineClass(env, "Canvas", {
    InstanceMethod<&[ClassName]::Func1>("Func1"),
    InstanceMethod<&[ClassName]::Func2>("Func2"),
    InstanceAccessor<&[ClassName]::ValueGetter>("Value"),
    StaticMethod<&[ClassName]::StaticMethod>("MethodName"),
    InstanceValue("Value", Napi::[Type]::New(env, value)),
  });

  constructor = Napi::Persistent(ctor);
  constructor .SuppressDestruct();
  exports.Set("[ClassName]", ctor);
}
```
  4. In Funktionen, in denen Sie das ObjectWrap in NAN, wie z. B. `[ClassName]* native = Nan::ObjectWrap::Unwrap<[ClassName]>(info.This());`, aufheben müssen, verwenden Sie `this` Zeiger direkt als nicht umschlossenes Objekt, da jede ObjectWrap-Instanz einer eindeutigen Objektinstanz zugeordnet ist.


Wenn Sie nach dieser Anleitung immer noch Probleme haben, beschreiben Sie uns das Problem bitte in einem Issue. Wir werden versuchen, es zu beheben.
