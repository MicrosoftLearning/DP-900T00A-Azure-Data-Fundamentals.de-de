---
ms.openlocfilehash: c6dc9b216d8255c51f2dc575a7c59dce25deff9e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051062"
---
<!--
  -- This file is auto-generated from README_js.md. Changes should be made there.
  -->

# <a name="uuid-cihttpsgithubcomuuidjsuuidactionsqueryworkflow3aci-browserhttpsgithubcomuuidjsuuidactionsqueryworkflow3abrowser"></a>uuid [![CI](https://github.com/uuidjs/uuid/workflows/CI/badge.svg)](https://github.com/uuidjs/uuid/actions?query=workflow%3ACI) [![Browser](https://github.com/uuidjs/uuid/workflows/Browser/badge.svg)](https://github.com/uuidjs/uuid/actions?query=workflow%3ABrowser)

Für die Erstellung von UUIDs gemäß [RFC4122](http://www.ietf.org/rfc/rfc4122.txt)

- **Vollständig** – Unterstützung für UUIDs gemäß RFC4122, Version 1, 3, 4 und 5
- **Plattformübergreifend**: Unterstützung für...
  - CommonJS, [ECMAScript-Module](#ecmascript-modules) und [CDN-Builds](#cdn-builds)
  - Node 8, 10, 12, 14
  - Browser: Chrome, Safari, Firefox, Edge, IE 11
  - Webpack- und rollup.js-Modulbündler
  - [React Native/Expo](#react-native--expo)
- **Sicher**: Kryptografisch starke Zufallswerte
- **Klein**: Nullabhängigkeit, niedriger Speicherbedarf, verträgt sich gut mit „Tree Shaking“-Packern
- **CLI**: Enthält das [`uuid`-Befehlszeilen](#command-line)hilfsprogramm

**Upgraden Sie von `uuid@3.x`?** Ihr Code ist wahrscheinlich in Ordnung, aber lesen Sie [Upgraden von`uuid@3.x`](#upgrading-from-uuid3x), um weitere Details zu erfahren.

## <a name="quickstart"></a>Schnellstart

So erstellen Sie eine zufällige UUID...

**1. Installieren**

```shell
npm install uuid
```

**2. Erstellen einer UUID** (ES6-Modulsyntax)

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4(); // ⇨ '9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d'
```

... oder Verwenden der CommonJS-Syntax:

```javascript
const { v4: uuidv4 } = require('uuid');
uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
```

Für Zeitstempel-UUIDs, Namespace-UUIDs und andere Optionen, lesen Sie weiter...

## <a name="api-summary"></a>API-Zusammenfassung

|  |  |  |
| --- | --- | --- |
| [`uuid.NIL`](#uuidnil) | Die Nullwert-UUID-Zeichenfolge (alles Nullen) | Neu in `uuid@8.3` |
| [`uuid.parse()`](#uuidparsestr) | Konvertieren einer UUID-Zeichenfolge in ein Array von Bytes | Neu in `uuid@8.3` |
| [`uuid.stringify()`](#uuidstringifyarr-offset) | Konvertieren eines Arrays von Bytes in eine UUID-Zeichenfolge | Neu in `uuid@8.3` |
| [`uuid.v1()`](#uuidv1options-buffer-offset) | Erstellen einer UUID, Version 1 (timestamp) |  |
| [`uuid.v3()`](#uuidv3name-namespace-buffer-offset) | Erstellen einer UUID, Version 3 (Namespace mit MD5) |  |
| [`uuid.v4()`](#uuidv4options-buffer-offset) | Erstellen einer UUID, Version 4 (zufällig) |  |
| [`uuid.v5()`](#uuidv5name-namespace-buffer-offset) | Erstellen einer UUID, Version 5 (Namespace mit SHA-1) |  |
| [`uuid.validate()`](#uuidvalidatestr) | Testen einer Zeichenfolge, um festzustellen, ob es sich um eine gültige UUID handelt | Neu in `uuid@8.3` |
| [`uuid.version()`](#uuidversionstr) | Erkennen der RFC-Version einer UUID | Neu in `uuid@8.3` |

## <a name="api"></a>API

### <a name="uuidnil"></a>uuid.NIL

Die Nullwert-UUID-Zeichenfolge (alles Nullen).

Beispiel:

```javascript
import { NIL as NIL_UUID } from 'uuid';

NIL_UUID; // ⇨ '00000000-0000-0000-0000-000000000000'
```

### <a name="uuidparsestr"></a>uuid.parse(str)

Konvertieren einer UUID-Zeichenfolge in ein Array von Bytes

|           |                                          |
| --------- | ---------------------------------------- |
| `str`     | Eine gültige UUID-`String`.                    |
| _gibt zurück_ | `Uint8Array[16]`                         |
| _löst aus_  | `TypeError`, wenn `str` keine gültige UUID ist. |

Hinweis: Die Anordnung von Werten in den Bytearrays, die von `parse()` und `stringify()` verwendet werden, folgt der Reihenfolge von „links &Rarr; rechts“ von Hexadezimal-Paaren in UUID-Zeichenfolgen. Wie im unten gezeigten Beispiel dargestellt.

Beispiel:

```javascript
import { parse as uuidParse } from 'uuid';

// Parse a UUID
const bytes = uuidParse('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b');

// Convert to hex strings to show byte order (for documentation purposes)
[...bytes].map((v) => v.toString(16).padStart(2, '0')); // ⇨ 
  // [
  //   '6e', 'c0', 'bd', '7f',
  //   '11', 'c0', '43', 'da',
  //   '97', '5e', '2a', '8a',
  //   'd9', 'eb', 'ae', '0b'
  // ]
```

### <a name="uuidstringifyarr-offset"></a>uuid.stringify(arr[, offset])

Konvertieren eines Arrays von Bytes in eine UUID-Zeichenfolge

|                |                                                                              |
| -------------- | ---------------------------------------------------------------------------- |
| `arr`          | `Array`-ähnliche Auflistung von 16 Werten (beginnend mit `offset`) von 0 bis 255. |
| [`offset` = 0] | `Number` Der Anfangsindex im Array.                                         |
| _gibt zurück_      | `String`                                                                     |
| _löst aus_       | `TypeError`, wenn keine gültige UUID-Zeichenfolge generiert werden kann.                       |

Hinweis: Die Anordnung von Werten in den Bytearrays, die von `parse()` und `stringify()` verwendet werden, folgt der Reihenfolge von „links &Rarr; rechts“ von Hexadezimal-Paaren in UUID-Zeichenfolgen. Wie im unten gezeigten Beispiel dargestellt.

Beispiel:

```javascript
import { stringify as uuidStringify } from 'uuid';

const uuidBytes = [
  0x6e,
  0xc0,
  0xbd,
  0x7f,
  0x11,
  0xc0,
  0x43,
  0xda,
  0x97,
  0x5e,
  0x2a,
  0x8a,
  0xd9,
  0xeb,
  0xae,
  0x0b,
];

uuidStringify(uuidBytes); // ⇨ '6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'
```

### <a name="uuidv1options-buffer-offset"></a>uuid.v1([options[, buffer[, offset]]])

Erstellen einer UUID gemäß RFC, Version 1 (timestamp)

|  |  |
| --- | --- |
| [`options`] | `Object` mit einer oder mehreren der folgenden Eigenschaften: |
| [`options.node` ] | RFC-Feld „node“ als `Array[6]` von Bytewerten (ab 4.1.6) |
| [`options.clockseq`] | RFC-Feld „clock sequence“ als `Number` zwischen 0 und 0x3fff |
| [`options.msecs`] | RFC-Feld „timestamp“ (`Number` von Millisekunden, Unix-Zeit (Epoch)) |
| [`options.nsecs`] | RFC-Feld „timestamp“ (`Number` von Nanosekunden, die `msecs` hinzugefügt werden sollen, sollte 0–10.000 sein) |
| [`options.random`] | `Array` von 16 zufälligen Bytes (0–255) |
| [`options.rng`] | Alternative zu `options.random`, ein `Function`-Wert, der ein `Array` von 16 zufälligen Bytes (0–255) zurückgibt. |
| [`buffer`] | `Array \| Buffer` Wenn angegeben, wird die UUID hier im Byteformat geschrieben, beginnend bei `offset`. |
| [`offset` = 0] | `Number` Index, bei dem begonnen wird, UUID-Bytes in `buffer` zu schreiben. |
| _gibt zurück_ | UUID-`String`, wenn kein `buffer` angegeben ist, andernfalls wird `buffer` zurückgegeben. |
| _löst aus_ | `Error`, wenn mehr als 10 M UUIDs/s angefordert werden. |

Hinweis: Die Standard-[Node-ID](https://tools.ietf.org/html/rfc4122#section-4.1.6) (die letzten 12 Ziffern in der UUID) wird einmalig zufällig beim Prozessstart generiert und bleibt dann für die Dauer des Prozesses unverändert.

Hinweis: `options.random` und `options.rng` sind nur beim ersten Aufruf von `v1()` von Bedeutung, bei dem sie übergeben werden können, um die internen Felder `node` und `clockseq` zu initialisieren.

Beispiel:

```javascript
import { v1 as uuidv1 } from 'uuid';

uuidv1(); // ⇨ '2c5ea4c0-4067-11e9-8bad-9b1deb4d3b7d'
```

Beispiel für die Verwendung von `options`:

```javascript
import { v1 as uuidv1 } from 'uuid';

const v1options = {
  node: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab],
  clockseq: 0x1234,
  msecs: new Date('2011-11-01').getTime(),
  nsecs: 5678,
};
uuidv1(v1options); // ⇨ '710b962e-041c-11e1-9234-0123456789ab'
```

### <a name="uuidv3name-namespace-buffer-offset"></a>uuid.v3(name, namespace[, buffer[, offset]])

Erstellen einer UUID gemäß RFC, Version 3 (Namespace mit MD5)

DIE API ist identisch mit `v5()`, verwendet aber stattdessen „v3“.

&#x26a0;&#xfe0f; Hinweis: Gemäß RFC: „_Wenn die Abwärtskompatibilität kein Problem ist, wird SHA-1 [Version 5] bevorzugt_“.

### <a name="uuidv4options-buffer-offset"></a>uuid.v4([options[, buffer[, offset]]])

Erstellen einer UUID gemäß RFC, Version 4 (random)

|  |  |
| --- | --- |
| [`options`] | `Object` mit einer oder mehreren der folgenden Eigenschaften: |
| [`options.random`] | `Array` von 16 zufälligen Bytes (0–255) |
| [`options.rng`] | Alternative zu `options.random`, ein `Function`-Wert, der ein `Array` von 16 zufälligen Bytes (0–255) zurückgibt. |
| [`buffer`] | `Array \| Buffer` Wenn angegeben, wird die UUID hier im Byteformat geschrieben, beginnend bei `offset`. |
| [`offset` = 0] | `Number` Index, bei dem begonnen wird, UUID-Bytes in `buffer` zu schreiben. |
| _gibt zurück_ | UUID-`String`, wenn kein `buffer` angegeben ist, andernfalls wird `buffer` zurückgegeben. |

Beispiel:

```javascript
import { v4 as uuidv4 } from 'uuid';

uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
```

Beispiel für die Verwendung vordefinierter `random`-Werte:

```javascript
import { v4 as uuidv4 } from 'uuid';

const v4options = {
  random: [
    0x10,
    0x91,
    0x56,
    0xbe,
    0xc4,
    0xfb,
    0xc1,
    0xea,
    0x71,
    0xb4,
    0xef,
    0xe1,
    0x67,
    0x1c,
    0x58,
    0x36,
  ],
};
uuidv4(v4options); // ⇨ '109156be-c4fb-41ea-b1b4-efe1671c5836'
```

### <a name="uuidv5name-namespace-buffer-offset"></a>uuid.v5(name, namespace[, buffer[, offset]])

Erstellen einer UUID gemäß RFC, Version 5 (Namespace mit SHA-1)

|  |  |
| --- | --- |
| `name` | `String \| Array` |
| `namespace` | `String \| Array[16]` Namespace-UUID |
| [`buffer`] | `Array \| Buffer` Wenn angegeben, wird die UUID hier im Byteformat geschrieben, beginnend bei `offset`. |
| [`offset` = 0] | `Number` Index, bei dem begonnen wird, UUID-Bytes in `buffer` zu schreiben. |
| _gibt zurück_ | UUID-`String`, wenn kein `buffer` angegeben ist, andernfalls wird `buffer` zurückgegeben. |

Hinweis: Die RFC-Namespaces `DNS` und `URL` sind als `v5.DNS` und `v5.URL` verfügbar.

Beispiel mit benutzerdefiniertem Namespace:

```javascript
import { v5 as uuidv5 } from 'uuid';

// Define a custom namespace.  Readers, create your own using something like
// https://www.uuidgenerator.net/
const MY_NAMESPACE = '1b671a64-40d5-491e-99b0-da01ff1f3341';

uuidv5('Hello, World!', MY_NAMESPACE); // ⇨ '630eb68f-e0fa-5ecc-887a-7c7a62614681'
```

Beispiel mit RFC-Namespace `URL`:

```javascript
import { v5 as uuidv5 } from 'uuid';

uuidv5('https://www.w3.org/', uuidv5.URL); // ⇨ 'c106a26a-21bb-5538-8bf2-57095d1976c1'
```

### <a name="uuidvalidatestr"></a>uuid.validate(str)

Testen einer Zeichenfolge, um festzustellen, ob es sich um eine gültige UUID handelt

|           |                                                     |
| --------- | --------------------------------------------------- |
| `str`     | Zu überprüfende `String`                                |
| _gibt zurück_ | `true`, wenn Zeichenfolge eine gültige UUID ist, andernfalls `false` |

Beispiel:

```javascript
import { validate as uuidValidate } from 'uuid';

uuidValidate('not a UUID'); // ⇨ false
uuidValidate('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'); // ⇨ true
```

Durch die gemeinsame Verwendung von `validate` und `version` ist es möglich, die Überprüfung pro Version durchzuführen, z. B. für nur UUIds der v4.

```javascript
import { version as uuidVersion } from 'uuid';
import { validate as uuidValidate } from 'uuid';

function uuidValidateV4(uuid) {
  return uuidValidate(uuid) && uuidVersion(uuid) === 4;
}

const v1Uuid = 'd9428888-122b-11e1-b85c-61cd3cbb3210';
const v4Uuid = '109156be-c4fb-41ea-b1b4-efe1671c5836';

uuidValidateV4(v4Uuid); // ⇨ true
uuidValidateV4(v1Uuid); // ⇨ false
```

### <a name="uuidversionstr"></a>uuid.version(str)

Erkennen der RFC-Version einer UUID

|           |                                          |
| --------- | ---------------------------------------- |
| `str`     | Eine gültige UUID-`String`.                    |
| _gibt zurück_ | `Number` Die RFC-Version der UUID     |
| _löst aus_  | `TypeError`, wenn `str` keine gültige UUID ist. |

Beispiel:

```javascript
import { version as uuidVersion } from 'uuid';

uuidVersion('45637ec4-c85f-11ea-87d0-0242ac130003'); // ⇨ 1
uuidVersion('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'); // ⇨ 4
```

## <a name="command-line"></a>Befehlszeile

UUIDs können über die Befehlszeile mithilfe von `uuid` generiert werden.

```shell
$ uuid
ddeb27fb-d9a0-4624-be4d-4615062daed4
```

Die Standardvorgehensweise besteht darin, UUIDs der Version 4 zu generieren, aber die anderen Versionen werden auch unterstützt. Geben Sie `uuid --help` ein, um ausführliche Informationen zu erhalten:

```shell
$ uuid --help

Usage:
  uuid
  uuid v1
  uuid v3 <name> <namespace uuid>
  uuid v4
  uuid v5 <name> <namespace uuid>
  uuid --help

Note: <namespace uuid> may be "URL" or "DNS" to use the corresponding UUIDs
defined by RFC4122
```

## <a name="ecmascript-modules"></a>ECMAScript-Module

Diese Bibliothek enthält Unterstützung der [ECMAScript-Module](https://www.ecma-international.org/ecma-262/6.0/#sec-modules) (ESM) für Node.js-Versionen, die diese unterstützen ([Beispiel](./examples/node-esmodules/)) sowie Bündler wie [rollup.js](https://rollupjs.org/guide/en/#tree-shaking) ([Beispiel](./examples/browser-rollup/)) und [webpack](https://webpack.js.org/guides/tree-shaking/) ([Beispiel](./examples/browser-webpack/)) (Ziel sind dabei beide, Node.js und Browserumgebungen).

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
```

Um die Beispiele auszuführen, müssen Sie zunächst einen Distributionsbuild dieser Bibliothek im Modulstamm erstellen:

```shell
npm run build
```

## <a name="cdn-builds"></a>CDN-Builds

### <a name="ecmascript-modules"></a>ECMAScript-Module

Um dieses Modul direkt in moderne Browser zu laden, die das [Laden von ECMAScript-Modulen unterstützen](https://caniuse.com/#feat=es6-module), können Sie [jspm](https://jspm.org/) verwenden:

```html
<script type="module">
  import { v4 as uuidv4 } from 'https://jspm.dev/uuid';
  console.log(uuidv4()); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
</script>
```

### <a name="umd"></a>UMD

Um dieses Modul direkt in ältere Browser zu laden, können Sie die [UMD (Universelle Moduldefinition)](https://github.com/umdjs/umd)-Builds aus jedem der folgenden CDNs verwenden:

**Verwenden von [UNPKG](https://unpkg.com/uuid@latest/dist/umd/)** :

```html
<script src="https://unpkg.com/uuid@latest/dist/umd/uuidv4.min.js"></script>
```

**Verwenden von [jsDelivr](https://cdn.jsdelivr.net/npm/uuid@latest/dist/umd/)** :

```html
<script src="https://cdn.jsdelivr.net/npm/uuid@latest/dist/umd/uuidv4.min.js"></script>
```

**Verwenden von [cdnjs](https://cdnjs.com/libraries/uuid)** :

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.1.0/uuidv4.min.js"></script>
```

Diese CDNs bieten alle dieselbe [`uuidv4()`](#uuidv4options-buffer-offset)-Methode:

```html
<script>
  uuidv4(); // ⇨ '55af1e37-0734-46d8-b070-a1e42e4fc392'
</script>
```

Methoden für die anderen Algorithmen ([`uuidv1()`](#uuidv1options-buffer-offset), [`uuidv3()`](#uuidv3name-namespace-buffer-offset) und [`uuidv5()`](#uuidv5name-namespace-buffer-offset)) sind jeweils in den Dateien `uuidv1.min.js`, `uuidv3.min.js` und `uuidv5.min.js` verfügbar.

## <a name="getrandomvalues-not-supported"></a>„getRandomValues() nicht unterstützt“

Dieser Fehler tritt in Umgebungen auf, in denen die Standard-[`crypto.getRandomValues()`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues)-API nicht unterstützt wird. Dieses Problem kann behoben werden, indem Sie ein entsprechendes Polyfill hinzufügen:

### <a name="react-native--expo"></a>React Native/Expo

1. Installieren von [`react-native-get-random-values`](https://github.com/LinusU/react-native-get-random-values#readme)
1. Importieren Sie es _vor_ `uuid`. Da `uuid` möglicherweise auch als transitive Abhängigkeit von einigen anderen Importen angezeigt wird, ist es am sichersten, nur `react-native-get-random-values` als erstes Element in Ihren Einstiegspunkt zu importieren:

```javascript
import 'react-native-get-random-values';
import { v4 as uuidv4 } from 'uuid';
```

Hinweis: Wenn Sie Expo verwenden, müssen Sie mindestens `react-native-get-random-values@1.5.0` und `expo@39.0.0` verwenden.

### <a name="web-workers--service-workers-edge--18"></a>Web-Worker/Service Worker (Edge <= 18)

[In Edge <= 18 wird Web Crypto in Web-Workern oder Service Workern nicht unterstützt](https://caniuse.com/#feat=cryptography), und wir kennen kein entsprechendes Polyfill (lassen Sie uns bitte wissen, wenn Sie eins finden).

## <a name="upgrading-from-uuid7x"></a>Upgraden von `uuid@7.x`

### <a name="only-named-exports-supported-when-using-with-nodejs-esm"></a>Bei Verwendung mit Node.js ESM werden nur benannte Exporte unterstützt

`uuid@7.x` besaß keine native Unterstützung für ECMAScript-Module (ESM) für Node.js. Wenn es in Node.js ESM importiert wurde, wurde konsequenterweise die CommonJS-Quelle mit einem Standardexport importiert. Diese Bibliothek verfügt jetzt über echte Unterstützung für Node.js ESM und bietet nur benannte Exporte.

Anstatt Folgendes zu tun:

```javascript
import uuid from 'uuid';
uuid.v4();
```

müssen Sie jetzt die benannten Exporte verwenden:

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4();
```

### <a name="deep-requires-no-longer-supported"></a>Deep-Anforderungen nicht mehr unterstützt

Deep-Anforderungen wie `require('uuid/v4')` [, die in `uuid@7.x`](#deep-requires-now-deprecated) eingestellt wurden, werden nicht mehr unterstützt.

## <a name="upgrading-from-uuid3x"></a>Upgraden von `uuid@3.x`

„_Moment..., was ist aus `uuid@4.x` - `uuid@6.x` geworden?!?_ “

Um Verwechslungen mit UUIDs gemäß RFC, [Version 4](#uuidv4options-buffer-offset) und [Version 5](#uuidv5name-namespace-buffer-offset) sowie einer möglichen [Version 6](http://gh.peabody.io/uuidv6/) zu vermeiden, wurden die Releases 4 bis 6 dieses Moduls übersprungen.

### <a name="deep-requires-now-deprecated"></a>Deep-Anforderungen jetzt veraltet

`uuid@3.x` hat die Verwendung von Deep-Anforderungen ermutigt, um die Bündelgröße von Browserbuilds zu minimieren:

```javascript
const uuidv4 = require('uuid/v4'); // <== NOW DEPRECATED!
uuidv4();
```

Seit `uuid@7.x` bietet dieser Bibliothek jetzt Builds mit ECMAScript-Modulen, die es Packern wie Webpack und Rollup gestatten, ein „Tree Shaking“ auszuführen, um toten Code zu entfernen. Verwenden Sie stattdessen die `import`-Syntax:

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4();
```

... oder für CommonJS:

```javascript
const { v4: uuidv4 } = require('uuid');
uuidv4();
```

### <a name="default-export-removed"></a>Standardexport entfernt

`uuid@3.x` hat standardmäßig Version 4 der UUID-Methode exportiert:

```javascript
const uuid = require('uuid'); // <== REMOVED!
```

Von diesem Verwendungsmuster wurde bereits in `uuid@3.x` abgeraten, und es wurde in `uuid@7.x` entfernt.

----
Aus [README_js.md](README_js.md) von [![RunMD-Logo](http://i.imgur.com/h0FVyzU.png)](https://github.com/broofa/runmd) generiertes Markdown