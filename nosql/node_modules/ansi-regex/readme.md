---
ms.openlocfilehash: 79b8bd5d8af7fd6d79dcb7c24b3f2e03e1d2a029
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051664"
---
# <a name="ansi-regex-build-statushttpstravis-ciorgchalkansi-regex"></a>ansi-regex [![Buildstatus](https://travis-ci.org/chalk/ansi-regex.svg?branch=master)](https://travis-ci.org/chalk/ansi-regex)

> Regulärer Ausdruck für den Abgleich von [ANSI-Escapecodes](http://en.wikipedia.org/wiki/ANSI_escape_code)


## <a name="install"></a>Installieren

```
$ npm install --save ansi-regex
```


## <a name="usage"></a>Verbrauch

```js
const ansiRegex = require('ansi-regex');

ansiRegex().test('\u001b[4mcake\u001b[0m');
//=> true

ansiRegex().test('cake');
//=> false

'\u001b[4mcake\u001b[0m'.match(ansiRegex());
//=> ['\u001b[4m', '\u001b[0m']
```

## <a name="faq"></a>Häufig gestellte Fragen

### <a name="why-do-you-test-for-codes-not-in-the-ecma-48-standard"></a>Warum testen Sie auf Codes, die nicht im ECMA 48-Standard enthalten sind?

Einige der Codes, die wir zu Testzwecken verwenden, sind Codes, die wir aus verschiedenen Listen mit nicht standardmäßigen oder herstellerspezifischen Codes bezogen haben. Wenn ich mich recht erinnere, testen wir sowohl auf standardmäßige als auch auf nicht standardmäßige Codes, da die meisten von ihnen das gleiche oder ein ähnliches Format haben und sicher in Zeichenfolgen abgeglichen werden können, ohne Gefahr zu laufen, den eigentlichen Inhalt der Zeichenfolge zu entfernen. Es gibt einige nicht standardmäßige Steuerelemente, die nicht dem üblichen Format entsprechen (d. h. auf Zahlen enden), sodass wir sie aus dem Test ausschließen müssen, da wir sie nicht zuverlässig abgleichen können.

Aus historischer Sicht wurden diese ECMA-Standards in den frühen 1990er Jahren festgelegt, während VT100 zum Beispiel Mitte/Ende der 1970er Jahre entwickelt wurde. Zu diesem Zeitpunkt waren Steuerungscodes noch ziemlich unkontrolliert und Entwickler nutzten sie für eine Vielzahl von Dingen, insbesondere um Hardwareanschlüsse zu aktivieren, die möglicherweise proprietär waren. Eine ähnliche „Anarchie“ von Codes findet sich auch in der x86-Architektur für Prozessoren. Es gibt eine Vielzahl von „Interrupts“, die bei bestimmten Prozessormarken unterschiedliche Bedeutungen haben können, von denen die meisten inzwischen aus dem Verkehr gezogen wurden.


## <a name="license"></a>Lizenz

MIT © [Sindre Sorhus](http://sindresorhus.com)
