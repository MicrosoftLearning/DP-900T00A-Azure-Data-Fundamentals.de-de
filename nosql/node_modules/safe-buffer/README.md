---
ms.openlocfilehash: 75916065970faa645bca603327ecbaea09afe12e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052988"
---
# <a name="safe-buffer-travistravis-imagetravis-url-npmnpm-imagenpm-url-downloadsdownloads-imagedownloads-url-javascript-style-guidestandard-imagestandard-url"></a>safe-buffer [![travis][travis-image]][travis-url] [![npm][npm-image]][npm-url] [![Downloads][downloads-image]][downloads-url] [![Styleguide für JavaScript][standard-image]][standard-url]

[travis-image]: https://img.shields.io/travis/feross/safe-buffer/master.svg
[travis-url]: https://travis-ci.org/feross/safe-buffer
[npm-image]: https://img.shields.io/npm/v/safe-buffer.svg
[npm-url]: https://npmjs.org/package/safe-buffer
[downloads-image]: https://img.shields.io/npm/dm/safe-buffer.svg
[downloads-url]: https://npmjs.org/package/safe-buffer
[standard-image]: https://img.shields.io/badge/code_style-standard-brightgreen.svg
[standard-url]: https://standardjs.com

#### <a name="safer-nodejs-buffer-api"></a>Sicherere Node.js-Puffer-API

**Verwenden Sie in allen Versionen von Node.js die neuen Node.js-Puffer-APIs (`Buffer.from`, `Buffer.alloc`, `Buffer.allocUnsafe`, `Buffer.allocUnsafeSlow`).**

**Verwendet die integrierte Implementierung, sofern verfügbar.**

## <a name="install"></a>Installieren

```
npm install safe-buffer
```

## <a name="usage"></a>Nutzung

Ziel dieses Pakets ist es, einen sicheren Ersatz für `Buffer` in node.js zu bieten.

Es handelt sich um einen einfachen Ersatz für `Buffer`. Sie können es verwenden, indem Sie eine `require`-Zeile am Anfang Ihrer node.js-Module hinzufügen:

```js
var Buffer = require('safe-buffer').Buffer

// Existing buffer code will continue to work without issues:

new Buffer('hey', 'utf8')
new Buffer([1, 2, 3], 'utf8')
new Buffer(obj)
new Buffer(16) // create an uninitialized buffer (potentially unsafe)

// But you can use these new explicit APIs to make clear what you want:

Buffer.from('hey', 'utf8') // convert from many types to a Buffer
Buffer.alloc(16) // create a zero-filled buffer (safe)
Buffer.allocUnsafe(16) // create an uninitialized buffer (potentially unsafe)
```

## <a name="api"></a>api

### <a name="class-method-bufferfromarray"></a>Klassenmethode: Buffer.from(array)
<!-- YAML
added: v3.0.0
-->

* `array` {Array}

Ordnet einen neuen `Buffer` unter Verwendung eines `array` von Oktetten zu.

```js
const buf = Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);
  // creates a new Buffer containing ASCII bytes
  // ['b','u','f','f','e','r']
```

`TypeError` wird ausgelöst, wenn `array` kein `Array` ist.

### <a name="class-method-bufferfromarraybuffer-byteoffset-length"></a>Klassenmethode: Buffer.from(arrayBuffer[, byteOffset[, length]])
<!-- YAML
added: v5.10.0
-->

* `arrayBuffer` {ArrayBuffer} Die `.buffer`-Eigenschaft von `TypedArray` oder `new ArrayBuffer()`
* `byteOffset` {Number}, Standard: `0`
* `length` {Number}, Standard: `arrayBuffer.length - byteOffset`

Wenn ein Verweis auf die `.buffer`-Eigenschaft einer `TypedArray`-Instanz übergeben wird, nutzt der neu erstellte `Buffer` denselben zugeteilten Arbeitsspeicher wie TypedArray.

```js
const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

const buf = Buffer.from(arr.buffer); // shares the memory with arr;

console.log(buf);
  // Prints: <Buffer 88 13 a0 0f>

// changing the TypedArray changes the Buffer also
arr[1] = 6000;

console.log(buf);
  // Prints: <Buffer 88 13 70 17>
```

Die optionalen Argumente `byteOffset` und `length` geben einen Arbeitsspeicherbereich innerhalb von `arrayBuffer` an, der vom `Buffer` gemeinsam genutzt wird.

```js
const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);
console.log(buf.length);
  // Prints: 2
```

`TypeError` wird ausgelöst, wenn `arrayBuffer` kein `ArrayBuffer` ist.

### <a name="class-method-bufferfrombuffer"></a>Klassenmethode: Buffer.from(buffer)
<!-- YAML
added: v3.0.0
-->

* `buffer` {Buffer}

Kopiert die übergebenen `buffer`-Daten in eine neue `Buffer`-Instanz.

```js
const buf1 = Buffer.from('buffer');
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;
console.log(buf1.toString());
  // 'auffer'
console.log(buf2.toString());
  // 'buffer' (copy is not changed)
```

`TypeError` wird ausgelöst, wenn `buffer` kein `Buffer` ist.

### <a name="class-method-bufferfromstr-encoding"></a>Klassenmethode: Buffer.from(str[, encoding])
<!-- YAML
added: v5.10.0
-->

* `str` {String}, zu codierende Zeichenfolge.
* `encoding` {String}, zu verwendende Codierung, Standard: `'utf8'`

Erstellt einen neuen `Buffer` mit der angegebenen JavaScript Zeichenfolge `str`. Falls angegeben, bestimmt der `encoding`-Parameter die Zeichencodierung.
Falls nicht, hat `encoding` die Standardeinstellung `'utf8'`.

```js
const buf1 = Buffer.from('this is a tést');
console.log(buf1.toString());
  // prints: this is a tést
console.log(buf1.toString('ascii'));
  // prints: this is a tC)st

const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');
console.log(buf2.toString());
  // prints: this is a tést
```

`TypeError` wird ausgelöst, wenn `str` keine Zeichenfolge ist.

### <a name="class-method-bufferallocsize-fill-encoding"></a>Klassenmethode: Buffer.alloc(size[, fill[, encoding]])
<!-- YAML
added: v5.10.0
-->

* `size` {Number}
* `fill` {Value}, Standard: `undefined`
* `encoding` {String}, Standard: `utf8`

Ordnet einen neuen `Buffer` mit `size` Bytes zu. Wenn `fill` gleich `undefined`, wird `Buffer` mit *Nullen gefüllt*.

```js
const buf = Buffer.alloc(5);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

`size` muss kleiner oder gleich dem Wert von `require('buffer').kMaxLength` sein (bei 64-Bit-Architekturen ist `kMaxLength` gleich `(2^31)-1`). Andernfalls wird [`RangeError`][] ausgelöst. Ein Puffer der Länge 0 wird erstellt, wenn `size` kleiner oder gleich 0 angegeben wird.

Wenn `fill` angegeben ist, wird der zugeordnete `Buffer` durch Aufrufen von `buf.fill(fill)` initialisiert. Weitere Informationen finden Sie unter [`buf.fill()`][].

```js
const buf = Buffer.alloc(5, 'a');
console.log(buf);
  // <Buffer 61 61 61 61 61>
```

Wenn `fill` und `encoding` angegeben sind, wird der zugeordnete `Buffer` durch Aufrufen von `buf.fill(fill, encoding)` initialisiert. Zum Beispiel:

```js
const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
console.log(buf);
  // <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
```

Das Aufrufen von `Buffer.alloc(size)` kann deutlich langsamer sein als die Alternative `Buffer.allocUnsafe(size)`, stellt aber sicher, dass der Inhalt der neu erstellten `Buffer`-Instanz *niemals vertrauliche Daten enthält* .

`TypeError` wird ausgelöst, wenn `size` keine Zahl ist.

### <a name="class-method-bufferallocunsafesize"></a>Klassenmethode: Buffer.allocUnsafe(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

Ordnet einen neuen *nicht mit Nullen gefüllten* `Buffer` von `size` Bytes zu.  `size` muss kleiner oder gleich dem Wert von `require('buffer').kMaxLength` sein (bei 64-Bit-Architekturen ist `kMaxLength` gleich `(2^31)-1`). Andernfalls wird [`RangeError`][] ausgelöst. Ein Puffer der Länge 0 wird erstellt, wenn `size` kleiner oder gleich 0 angegeben wird.

Der zugrunde liegende Arbeitsspeicher für `Buffer`-Instanzen, die auf diese Weise erstellt werden, wird *nicht initialisiert*. Der Inhalt des neu erstellten `Buffer` ist unbekannt und *könnte vertrauliche Daten enthalten* . Verwenden Sie [`buf.fill(0)`][], um solche `Buffer`-Instanzen mit Nullen zu initialisieren.

```js
const buf = Buffer.allocUnsafe(5);
console.log(buf);
  // <Buffer 78 e0 82 02 01>
  // (octets will be different, every time)
buf.fill(0);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

`TypeError` wird ausgelöst, wenn `size` keine Zahl ist.

Beachten Sie, dass das `Buffer`-Modul eine interne `Buffer`-Instanz der Größe `Buffer.poolSize` vorab zuordnet, die als Pool für die schnelle Zuweisung neuer `Buffer`-Instanzen verwendet wird, die mit `Buffer.allocUnsafe(size)` (und dem veralteten `new Buffer(size)`-Konstruktor) nur dann erstellt werden, wenn `size` kleiner oder gleich `Buffer.poolSize >> 1` ist (Untergrenze `Buffer.poolSize` geteilt durch 2). Der Standardwert von `Buffer.poolSize` ist `8192`, kann aber geändert werden.

Die Verwendung dieses vorab zugeordneten internen Arbeitsspeicherpools ist ein wesentlicher Unterschied beim Aufruf von `Buffer.alloc(size, fill)` gegenüber `Buffer.allocUnsafe(size).fill(fill)`. Konkret verwendet `Buffer.alloc(size, fill)` *niemals*  den internen Pufferpool, während `Buffer.allocUnsafe(size).fill(fill)` den internen Pufferpool *verwendet*, wenn `size` kleiner oder gleich der Hälfte von `Buffer.poolSize` ist. Der Unterschied ist zwar nur geringfügig, kann aber wichtig sein, wenn eine Anwendung die zusätzliche Leistung benötigt, die `Buffer.allocUnsafe(size)` bietet.

### <a name="class-method-bufferallocunsafeslowsize"></a>Klassenmethode: Buffer.allocUnsafeSlow(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

Ordnet einen neuen *nicht mit Nullen gefüllten* und nicht poolbasierten `Buffer` von `size` Bytes zu.  `size` muss kleiner oder gleich dem Wert von `require('buffer').kMaxLength` sein (bei 64-Bit-Architekturen ist `kMaxLength` gleich `(2^31)-1`). Andernfalls wird [`RangeError`][] ausgelöst. Ein Puffer der Länge 0 wird erstellt, wenn `size` kleiner oder gleich 0 angegeben wird.

Der zugrunde liegende Arbeitsspeicher für `Buffer`-Instanzen, die auf diese Weise erstellt werden, wird *nicht initialisiert*. Der Inhalt des neu erstellten `Buffer` ist unbekannt und *könnte vertrauliche Daten enthalten* . Verwenden Sie [`buf.fill(0)`][], um solche `Buffer`-Instanzen mit Nullen zu initialisieren.

Wenn Sie `Buffer.allocUnsafe()` verwenden, um neue `Buffer`-Instanzen zuzuordnen, werden Zuordnungen unter 4 KB standardmäßig von einem einzelnen vorab zugeordneten `Buffer` segmentiert. Dadurch können Anwendungen den Aufwand für automatische Speicherbereinigung vermeiden, der durch die Erstellung vieler individuell zugeordneter Puffer entsteht. Dieser Ansatz verbessert sowohl die Leistung als auch die Arbeitsspeicherauslastung, da nicht mehr so viele `Persistent`-Objekte nachverfolgt und bereinigt werden müssen.

Wenn ein Entwickler jedoch einen kleinen Teil des Arbeitsspeichers aus einem Pool für eine unbestimmte Zeit zurückhalten muss, kann es sinnvoll sein, mit `Buffer.allocUnsafeSlow()` eine nicht poolbasierte Pufferinstanz zu erstellen und dann die relevanten Bits herauszukopieren.

```js
// need to keep around a few small chunks of memory
const store = [];

socket.on('readable', () => {
  const data = socket.read();
  // allocate for retained data
  const sb = Buffer.allocUnsafeSlow(10);
  // copy the data into the new allocation
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});
```

Die Verwendung von `Buffer.allocUnsafeSlow()` sollte nur als letztes Mittel eingesetzt werden, *nachdem* ein Entwickler eine unangemessene Zurückbehaltung von Arbeitsspeicher in seinen Anwendungen beobachtet hat.

`TypeError` wird ausgelöst, wenn `size` keine Zahl ist.

### <a name="all-the-rest"></a>Der gesamte Rest

Der Rest der `Buffer`-API ist mit node.js identisch.
[Lesen Sie die Dokumentation](https://nodejs.org/api/buffer.html).


## <a name="related-links"></a>Verwandte Links

- [Problem in Node.js: Buffer(number) ist unsicher](https://github.com/nodejs/node/issues/4660)
- [Verbesserungsvorschlag für Node.js: Buffer.from/Buffer.alloc/Buffer.zalloc/Buffer() soft-deprecate](https://github.com/nodejs/node-eps/pull/4)

## <a name="why-is-buffer-unsafe"></a>Warum ist `Buffer` unsicher?

Heutzutage ist der `Buffer`-Konstruktor von node.js überladen, um mit vielen verschiedenen Argumenttypen wie `String`, `Array`, `Object`, `TypedArrayView` (`Uint8Array`, usw.), `ArrayBuffer`, und auch `Number` zurecht zu kommen.

Die API ist auf Zweckmäßigkeit optimiert. Sie können ihr jeden Typ zuweisen, und sie wird versuchen, das Gewünschte zu tun.

Da der „Buffer“-Konstruktor so leistungsfähig ist, sehen Sie oft Code wie diesen:

```js
// Convert UTF-8 strings to hex
function toHex (str) {
  return new Buffer(str).toString('hex')
}
```

***Aber was passiert, wenn `toHex` mit einem `Number`-Argument aufgerufen wird?***

### <a name="remote-memory-disclosure"></a>Offenlegung von Remotespeicher

Wenn ein Angreifer Ihr Programm dazu bringen kann, den `Buffer`-Konstruktor mit einem `Number`-Argument aufzurufen, kann er es dazu bringen, nicht initialisierten Arbeitsspeicher aus dem node.js-Prozess zuzuordnen.
Dadurch können möglicherweise private TLS-Schlüssel, Benutzerdaten oder Datenbankkennwörter preisgegeben werden.

Wenn dem `Buffer`-Konstruktor ein `Number`-Argument übergeben wird, gibt er einen **NICHT INITIALISIERTEN** Arbeitsspeicherblock mit der angegebenen `size` zurück. Wenn Sie einen `Buffer` wie diesen erstellen, **müssen** Sie den Inhalt überschreiben, ehe Sie ihn an den Benutzer zurückgeben.

In der [node.js-Dokumentation](https://nodejs.org/api/buffer.html#buffer_new_buffer_size):

> `new Buffer(size)`
>
> - Wert für `size`
>
> Der zugrunde liegende Arbeitsspeicher für `Buffer`-Instanzen, die auf diese Weise erstellt werden, wird nicht initialisiert.
> **Der Inhalt eines neu erstellten `Buffer` ist unbekannt und könnte vertrauliche Daten enthalten.** Verwenden Sie `buf.fill(0)`, um einen Puffer mit Nullen zu initialisieren.

(Hervorhebung unsererseits.)

Immer, wenn der Programmierer beabsichtigt, einen nicht initialisierten `Buffer` zu erstellen, sehen Sie oft Code wie diesen:

```js
var buf = new Buffer(16)

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="would-this-ever-be-a-problem-in-real-code"></a>Wäre dies in realem Code jemals ein Problem?

Ja. In einer dynamisch typisierten Sprache wie JavaScript wird häufig vergessen, den Typ Ihrer Variablen zu überprüfen.

Normalerweise führt die Annahme eines falschen Typs dazu, dass Ihr Programm mit einer nicht abgefangenen Ausnahme abstürzt. Aber die Fehlermöglichkeit, bei der vergessen wurde, den Typ der Argumente für den `Buffer`-Konstruktor zu überprüfen, ist noch katastrophaler.

Hier ist ein Beispiel eines anfälligen Diensts, der JSON-Nutzdaten in Hexadezimalzahlen umwandelt:

```js
// Take a JSON payload {str: "some string"} and convert it to hex
var server = http.createServer(function (req, res) {
  var data = ''
  req.setEncoding('utf8')
  req.on('data', function (chunk) {
    data += chunk
  })
  req.on('end', function () {
    var body = JSON.parse(data)
    res.end(new Buffer(body.str).toString('hex'))
  })
})

server.listen(8080)
```

In diesem Beispiel muss ein HTTP Client nur Folgendes senden:

```json
{
  "str": 1000
}
```

und erhält 1.000 Byte nicht initialisierten Arbeitsspeicher vom Server zurück.

Dies ist ein sehr schwerwiegender Fehler. Er ist ähnlich schwerwiegend wie der [Heartbleed-Fehler](http://heartbleed.com/), der es externen Angreifern ermöglichte, den Arbeitsspeicher von OpenSSL offenzulegen.


### <a name="which-real-world-packages-were-vulnerable"></a>Welche konkreten Pakete waren anfällig?

#### [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht)

[Mathias Buus](https://github.com/mafintosh) und ich ([Feross Aboukhadijeh](http://feross.org/)) haben dieses Problem in einem unserer eigenen Pakete gefunden, [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht). Der Fehler ermöglicht es jedem im Internet, eine Reihe von Nachrichten an einen Benutzer von `bittorrent-dht` zu senden und ihn dazu zu bringen, jeweils 20 Byte nicht initialisierten Arbeitsspeicher aus dem node.js-Prozess preiszugeben.

Hier ist der [Commit](https://github.com/feross/bittorrent-dht/commit/6c7da04025d5633699800a99ec3fbadf70ad35b8), mit dem das Problem behoben wurde. Wir haben eine neue korrigierte Version veröffentlicht, eine [Node Security Project-Offenlegung](https://nodesecurity.io/advisories/68) erstellt und alle anfälligen Versionen von npm als veraltet gekennzeichnet, sodass Benutzer eine Warnung mit einer Aufforderung zum Upgrade auf eine neuere Version erhalten.

#### [`ws`](https://www.npmjs.com/package/ws)

Das brachte uns zur Frage, ob es noch andere anfällige Pakete gibt. Tatsächlich fanden wir innerhalb kurzer Zeit das gleiche Problem in [`ws`](https://www.npmjs.com/package/ws) vor, der beliebtesten WebSocket-Implementierung in node.js.

Wenn bestimmte APIs mit `Number`-Parametern statt wie erwartet mit `String` oder `Buffer` aufgerufen wurden, wurde der nicht initialisierte Serverarbeitsspeicher für den Remotepeer offengelegt.

Dies waren die anfälligen Methoden:

```js
socket.send(number)
socket.ping(number)
socket.pong(number)
```

Hier ist ein anfälliger Socketserver mit einigen Echofunktionen:

```js
server.on('connection', function (socket) {
  socket.on('message', function (message) {
    message = JSON.parse(message)
    if (message.type === 'echo') {
      socket.send(message.data) // send back the user's message
    }
  })
})
```

Wenn `socket.send(number)` auf dem Server aufgerufen wird, wird der Arbeitsspeicher des Servers offengelegt.

Hier ist das [Release](https://github.com/websockets/ws/releases/tag/1.0.1), in dem das Problem behoben wurde, mit einer ausführlicheren Erläuterung. Ein Lob geht an [Arnout Kazemier](https://github.com/3rd-Eden) für die schnelle Lösung. Hier finden Sie die [Node Security Project-Offenlegung](https://nodesecurity.io/advisories/67).


### <a name="whats-the-solution"></a>Wie lautet die Lösung?

Es ist wichtig, dass node.js eine schnelle Möglichkeit bietet, Arbeitsspeicher zu erhalten, da sonst leistungskritische Anwendungen unnötig viel langsamer werden würden.

Aber wir benötigen eine bessere Möglichkeit, als Programmierer *unsere Absicht zu signalisieren*. **Wenn wir nicht initialisierten Arbeitsspeicher benötigen, müssen wir ihn explizit anfordern.**

Sensible Funktionalität sollte nicht in eine entwicklerfreundliche API gepackt werden, die großzügig viele verschiedene Typen zulässt. Diese Art von API fördert die bequeme Praxis, Variablen zu übergeben, ohne den Typ sorgfältig zu prüfen.

#### <a name="a-new-api-bufferallocunsafenumber"></a>Eine neue API: `Buffer.allocUnsafe(number)`

Die Funktion zum Erstellen von Puffern mit nicht initialisiertem Arbeitsspeicher sollte Teil einer anderen API sein. Wir schlagen `Buffer.allocUnsafe(number)` vor. Auf diese Weise ist diese Funktion nicht Teil einer API, an die häufig Benutzereingaben aller möglichen Arten übergeben werden.

```js
var buf = Buffer.allocUnsafe(16) // careful, uninitialized memory!

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="how-do-we-fix-nodejs-core"></a>Wie korrigieren wir node.js core?

Wir haben [einen Pull Request (PR) an node.js core](https://github.com/nodejs/node/pull/4514) (gemergt als `semver-major`) gesendet, der einen Fall abwehrt:

```js
var str = 16
new Buffer(str, 'utf8')
```

In dieser Situation ist davon auszugehen, dass der Programmierer das erste Argument als Zeichenfolge vorgesehen hat, da er als zweites Argument eine Codierung übergeben hat. Derzeit ordnet node.js im Fall von `new Buffer(number, encoding)` nicht initialisierten Arbeitsspeicher zu, was wahrscheinlich nicht im Sinne des Programmierers ist.

Aber das ist nur eine Teillösung, denn wenn der Programmierer `new Buffer(variable)` (ohne `encoding`-Parameter) angibt, gibt es keine Möglichkeit zu wissen, was beabsichtigt ist. Wenn `variable` mitunter eine Zahl ist, wird manchmal nicht initialisierter Arbeitsspeicher zurückgegeben.

### <a name="whats-the-real-long-term-fix"></a>Wie sieht die echte langfristige Lösung aus?

Wir könnten `new Buffer(number)` als veraltet einstufen und entfernen und `Buffer.allocUnsafe(number)` verwenden, wenn wir nicht initialisierten Arbeitsspeicher benötigen. Aber dadurch würden Tausende von Paketen unbrauchbar.

~~Unserer Meinung nach ist die beste Lösung wie folgt:~~

~~1. Ändern Sie `new Buffer(number)` so, dass sicherer, gelöschter Arbeitsspeicher zurückgegeben wird~~.

~~2. Erstellen Sie eine neue API zum Erstellen nicht initialisierter Puffer. Unser Vorschlag: `Buffer.allocUnsafe(number)`~~

#### <a name="update"></a>Aktualisieren

Wir unterstützen jetzt das Hinzufügen von drei neuen APIs:

- `Buffer.from(value)`: von einem beliebigen Typ in einen Puffer konvertieren
- `Buffer.alloc(size)`: einen mit Nullen gefüllten Puffer erstellen
- `Buffer.allocUnsafe(size)`: einen nicht initialisierten Puffer der angegebenen Größe erstellen

Dies löst das Kernproblem, das `ws` und `bittorrent-dht` betraf, nämlich dass `Buffer(variable)` dazu verleitet wurde, ein numerisches Argument anzunehmen.

Auf diese Weise funktioniert der vorhandene Code weiterhin, und die Auswirkungen auf das npm-Ökosystem werden minimal sein. Im Laufe der Zeit können npm-Betreuer leistungskritischen Code auf die Verwendung von `Buffer.allocUnsafe(number)` statt `new Buffer(number)` umstellen.


### <a name="conclusion"></a>Schlussbemerkung

Wir denken, dass die `Buffer`-API in ihrer jetzigen Form ein ernsthaftes Entwurfsproblem aufweist. Sie fördert unsichere Software, indem sie hochriskante Funktionalität in eine bequeme API mit entwicklerfreundlicher „Ergonomie“ packt.

Dies war nicht nur eine theoretische Übung, denn wir haben das Problem in einigen der beliebtesten npm-Pakete gefunden.

Zum Glück gibt es eine einfache Lösung, die Sie heute schon umsetzen können. Verwenden Sie `safe-buffer` anstelle von `buffer`.

```js
var Buffer = require('safe-buffer').Buffer
```

Wir hoffen, dass node.js core irgendwann auf dieses neue, sicherere Verhalten umgestellt werden kann. Wir glauben, dass die Auswirkungen auf das Ökosystem minimal wären, da es sich nicht um einen Breaking Change handelt.
Gut gepflegte, beliebte Pakete lassen sich schnell auf die Verwendung von `Buffer.alloc` umstellen, während ältere, unsichere Pakete auf „magische“ Weise vor diesem Angriffsvektor sicher werden.


## <a name="links"></a>Verknüpfungen

- [Pull Request für Node.js: Puffer: auslösen, wenn sowohl „length“ als auch „enc“ übergeben werden](https://github.com/nodejs/node/pull/4514)
- [Node Security Project-Offenlegung für `ws`](https://nodesecurity.io/advisories/67)
- [Node Security Project-Offenlegung für `bittorrent-dht`](https://nodesecurity.io/advisories/68)


## <a name="credit"></a>Danksagung

Die ursprünglichen Probleme in `bittorrent-dht` ([Offenlegung](https://nodesecurity.io/advisories/68)) und `ws` ([Offenlegung](https://nodesecurity.io/advisories/67)) wurden von [Mathias Buus](https://github.com/mafintosh) und [Feross Aboukhadijeh](http://feross.org/) entdeckt.

Vielen Dank an [Adam Baldwin](https://github.com/evilpacket) für seine Hilfe bei der Offenlegung dieser Probleme und für seine Arbeit als [Node Security Project](https://nodesecurity.io/)-Leiter.

Vielen Dank an [John Hiesey](https://github.com/jhiesey) für das Korrekturlesen dieser Infodatei und Prüfen des Codes.


## <a name="license"></a>license

MIT. Copyright (C) [Feross Aboukhadijeh](http://feross.org)
