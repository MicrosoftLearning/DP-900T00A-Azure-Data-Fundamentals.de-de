---
ms.openlocfilehash: b8e00448fe7f8445c8e81302b03a852ee0f7e5cc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051736"
---
<a name="aproba"></a>aproba
======

Ein überaus schlankes Validierungssteuerelement für Funktionsargumente

```
var validate = require("aproba")

function myfunc(a, b, c) {
  // `a` must be a string, `b` a number, `c` a function
  validate('SNF', arguments) // [a,b,c] is also valid
}

myfunc('test', 23, function () {}) // ok
myfunc(123, 23, function () {}) // type error
myfunc('test', 23) // missing arg error
myfunc('test', 23, function () {}, true) // too many args error

```

Gültige Typen sind:

| Typ | description
| :--: | :----------
| *    | entspricht jedem Typ
| Ein    | `Array.isArray` ODER ein `arguments`-Objekt
| E    | typeof == Zeichenfolge
| N    | typeof == Zahl
| F    | typeof == Funktion
| O    | typeof == Objekt und nicht Typ A und nicht Typ E
| B    | typeof == boolescher Wert
| E    | `instanceof Error` ODER `null` **(Spezialfall: siehe unten)**
| Z    | == `null`

Validierungsfehler lösen eine von drei Ausnahmen aus, die sich durch eine `code`-Eigenschaft von `EMISSINGARG`, `EINVALIDTYPE` oder `ETOOMANYARGS` unterscheiden.

Wenn Sie einen ungültigen Typ eingeben, wird der Code `EUNKNOWNTYPE` ausgelöst.

Wenn ein **error**-Argument gefunden wird und nicht NULL ist, sind die übrigen Argumente optional.  Das heißt, wenn Sie `ESO` sagen, dann ist das so, als würden Sie ein nicht-magisches `E` in `E|ESO|ZSO` verwenden.

### <a name="but-i-have-optional-arguments"></a>Aber ich habe optionale Argumente?!

Sie können mehrere Signaturen bereitstellen, indem Sie sie mit Pipes `|` trennen.
Wenn eine Signatur den Argumenten entspricht, werden sie als gültig betrachtet.

Angenommen, Sie möchten eine Signatur für `fs.createWriteStream` schreiben.  In der Dokumentation wird dies folgendermaßen beschrieben:

```
fs.createWriteStream(path[, options])
```

Dies wäre eine Signatur von `SO|S`.  Das heißt, eine Zeichenfolge und ein Objekt oder nur eine Zeichenfolge.

Wenn Sie die vollständige `fs`-Dokumentation lesen, werden Sie feststellen, dass der Pfad tatsächlich auch ein Puffer sein kann.  Und Optionen können eine Zeichenfolge sein, das heißt:
```
path <String> | <Buffer>
options <String> | <Object>
```

Um dies zu reproduzieren, müssen Sie alle möglichen Kombinationen vollständig aufzählen, und das impliziert die Signatur `SO|SS|OO|OS|S|O`.  Die Umständlichkeit ist ein Feature: Sie erinnert Sie an die Komplexität, die Sie Ihrer API hinzufügen, wenn Sie diese Art von Dingen tun.


### <a name="browser-support"></a>Browserunterstützung

Diese Variante hat keine Abhängigkeiten und sollte in Browsern funktionieren, auch wenn die Stapelüberwachungen unruhiger sein werden.

### <a name="why-this-exists"></a>Gründe, warum dies vorhanden ist

Ich wollte ein sehr einfaches Validierungssteuerelement für Argumente. Es sollte zwei Kriterien erfüllen:

1. mehr Präzision und einfache Verwendung als bei Assertionen

2. Kein Fördern eines unendlichen Bikesheddings von DSLs

Aus diesem Grund werden Typen durch ein einzelnes Zeichen angegeben, und es gibt kein optionales Argument. 

Dies dient nicht der Überprüfung von Benutzerdaten. Hier geht es speziell um die Assertion der Schnittstelle Ihrer Funktionen.

Wenn Sie eine umfassendere Validierung benötigen, empfehle ich Ihnen, sie von Hand zu schreiben oder sich anderweitig umzusehen.

