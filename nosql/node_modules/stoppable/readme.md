---
ms.openlocfilehash: 03ad292b1fceecb8974f1d8753cb47723344dbf3
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051584"
---
# <a name="stoppable"></a>Stoppable

[![Buildstatus](https://travis-ci.org/hunterloftis/stoppable.svg?branch=master)](https://travis-ci.org/hunterloftis/stoppable)

> `server.close()` von Node arbeitet so, wie Sie wahrscheinlich [erwartet haben, dass sie standardmäßig funktioniert](https://github.com/nodejs/node/issues/2642).

## <a name="summary"></a>Zusammenfassung

```js
const server = stoppable(http.createServer(handler))
server.stop()
```

Stoppable beendet die Annahme neuer Verbindungen und schließt vorhandene Leerlaufverbindungen (einschließlich Keep-Alives), ohne Anforderungen zu beenden, die im Flight enthalten sind.

## <a name="requirements"></a>Requirements (Anforderungen)

- Node.js v6+

Node.js v4.x wird *inoffiziell* unterstützt.

## <a name="installation"></a>Installation

```bash
yarn add stoppable
```

(oder npm verwenden)

## <a name="usage"></a>Verbrauch

**constructor**

```js
stoppable(server, grace)
```

Ergänzt die Serverinstanz um eine `stop`-Methode.
Gibt die Serverinstanz zurück, sodass sie verkettet oder als eigenständige Anweisung ausgeführt werden kann.

- server: Jede HTTP- oder HTTPS-Serverinstanz.
- grace: Millisekunden, die bis zum erzwungenen Schließen (force-closing) von Verbindungen zu warten ist.

`grace` nimmt den Standardwert „Unendlich“ (infinity; Schließen nicht erzwingen (force-close)) an.
Wenn Sie alle Sockets sofort schließen möchten, können Sie einen „grace“-Wert von 0 verwenden.

**stop()**

```js
server.stop(callback)
```

Schließt den Server.

- callback: Wird an die vorhandene `server.close`-Funktion übergeben, um ein „close“-Ereignis automatisch zu registrieren.
Das erste Argument ist ein Fehler, und das zweite Argument ist ein boolescher Wert, der angibt, ob er ordnungsgemäß beendet wurde.

## <a name="design-decisions"></a>Entwurfsentscheidungen

- Monkey Patching ist in der Regel unangenehm, doch in diesem Fall ist es die angenehmste API. Nennen wir es „Ergänzen“.
- `grace` könnte für `stop` angegeben werden, aber es ist besser, sich an der vorhandenen `server.close`-API zu orientieren.
- Clients sollten respektvoll behandelt werden, sodass wir nicht nur einfach Sockets zerstören, sondern zuerst `FIN`-Pakete senden.
- Jede Lösung für dieses Problem erfordert die Buchführung über jede Verbindung und Anforderung/Antwort.
Wir investieren ein Minimum an Arbeit in diese „heißen“ Codepfade und verzögern so viel wie möglich hin zur tatsächlichen `stop`-Methode.

## <a name="performance"></a>Leistung

Es gibt keine Möglichkeit, diese Funktionalität bereitzustellen, ohne über Verbindungen, Verbindungstrennungen, Anforderungen und Antworten Buch zu führen.
Stoppable versucht jedoch, minimale Arbeit in heiße Codepfade zu investieren und optimale Datenstrukturen zu verwenden.

Ich wäre daran interessiert, reale Leistungsvergleiche zu sehen. Der einfache Loopback-Artillery-Benchmark, der in der Bibliothek enthalten ist, zeigt sehr geringen Mehraufwand durch die Verwendung eines stoppable Servers:

### <a name="without-stoppable"></a>Ohne stoppable

```plain
  Scenarios launched:  10000
  Scenarios completed: 10000
  Requests completed:  10000
  RPS sent: 939.85
  Request latency:
    min: 0.5
    max: 51.3
    median: 2.1
    p95: 3.7
    p99: 15.3
  Scenario duration:
    min: 1
    max: 60.7
    median: 3.6
    p95: 7.6
    p99: 19
  Scenario counts:
    0: 10000 (100%)
  Codes:
    200: 10000
```

### <a name="with-stoppable"></a>Mit stoppable

```plain
  Scenarios launched:  10000
  Scenarios completed: 10000
  Requests completed:  10000
  RPS sent: 940.73
  Request latency:
    min: 0.5
    max: 43.4
    median: 2.1
    p95: 3.8
    p99: 15.5
  Scenario duration:
    min: 1.1
    max: 57
    median: 3.7
    p95: 8
    p99: 19.4
  Scenario counts:
    0: 10000 (100%)
  Codes:
    200: 10000
```

## <a name="license"></a>Lizenz

MIT