---
ms.openlocfilehash: c0d4bfc80d62125554d466fe2b45375ed815b043
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051479"
---
# <a name="jsonwebtoken"></a>jsonwebtoken

| **Build** | **Abhängigkeit** |
|-----------|---------------|
| [![Buildstatus](https://secure.travis-ci.org/auth0/node-jsonwebtoken.svg?branch=master)](http://travis-ci.org/auth0/node-jsonwebtoken) | [![Abhängigkeitsstatus](https://david-dm.org/auth0/node-jsonwebtoken.svg)](https://david-dm.org/auth0/node-jsonwebtoken) |


Eine Implementierung von [JSON-Webtoken](https://tools.ietf.org/html/rfc7519).

Diese wurde für `draft-ietf-oauth-json-web-token-08` entwickelt. Sie verwendet [node-jws](https://github.com/brianloveswords/node-jws).

# <a name="install"></a>Installieren

```bash
$ npm install jsonwebtoken
```

# <a name="migration-notes"></a>Migrationshinweise

* [Von v7 zu v8](https://github.com/auth0/node-jsonwebtoken/wiki/Migration-Notes:-v7-to-v8)

# <a name="usage"></a>Verbrauch

### <a name="jwtsignpayload-secretorprivatekey-options-callback"></a>jwt.sign(payload, secretOrPrivateKey, [options, callback])

(asynchron) Wenn ein Rückruf bereitgestellt wird, wird der Rückruf mit `err` oder dem JWT aufgerufen.

(Synchron) Gibt das JsonWebToken als Zeichenfolge zurück

`payload` kann ein Objektliteral, ein Puffer oder eine Zeichenfolge sein, die gültiges JSON darstellt. 
> **_Beachten_ Sie, dass** `exp` oder ein anderer Anspruch nur festgelegt wird, wenn die Nutzdaten ein Objektliteral sind. Puffer- oder Zeichenfolgennutzdaten werden nicht auf Gültigkeit für JSON überprüft.

> Wenn `payload` kein Puffer bzw. keine Zeichenfolge ist, wird das Element per `JSON.stringify` in eine Zeichenfolge umgewandelt.

`secretOrPrivateKey` ist eine Zeichenfolge, ein Puffer oder ein Objekt, das entweder das Geheimnis für HMAC-Algorithmen oder den PEM-codierten privaten Schlüssel für RSA und ECDSA enthält. Bei einem privaten Schlüssel mit Passphrase kann ein `{ key, passphrase }`-Objekt verwendet werden (basierend auf der [Kryptodokumentation](https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format)). Stellen Sie in diesem Fall sicher, dass Sie die Option `algorithm` übergeben.

`options`:

* `algorithm` (Standard: `HS256`)
* `expiresIn`: ausgedrückt in Sekunden oder eine Zeichenfolge, die eine Zeitspanne beschreibt [zeit/ms](https://github.com/zeit/ms). 
  > Beispiel: `60`, `"2 days"`, `"10h"`, `"7d"`. Ein numerischer Wert wird als Sekundenanzahl interpretiert. Wenn Sie eine Zeichenfolge verwenden, stellen Sie sicher, dass Sie die Zeiteinheiten angeben (Tage, Stunden usw.). Andernfalls wird standardmäßig die Einheit Millisekunden verwendet (`"120"` gleich `"120ms"`).
* `notBefore`: ausgedrückt in Sekunden oder eine Zeichenfolge, die eine Zeitspanne beschreibt [zeit/ms](https://github.com/zeit/ms). 
  > Beispiel: `60`, `"2 days"`, `"10h"`, `"7d"`. Ein numerischer Wert wird als Sekundenanzahl interpretiert. Wenn Sie eine Zeichenfolge verwenden, stellen Sie sicher, dass Sie die Zeiteinheiten angeben (Tage, Stunden usw.). Andernfalls wird standardmäßig die Einheit Millisekunden verwendet (`"120"` gleich `"120ms"`).
* `audience`
* `issuer`
* `jwtid`
* `subject`
* `noTimestamp`
* `header`
* `keyid`
* `mutatePayload`: falls TRUE, ändert die Vorzeichenfunktion das Objekt der Nutzdaten direkt. Dies ist nützlich, wenn Sie einen unbearbeiteten Verweis auf die Nutzdaten benötigen, nachdem Ansprüche auf sie angewendet wurden, aber bevor sie in ein Token codiert wurden.



> Es gibt keine Standardwerte für `expiresIn`, `notBefore`, `audience`, `subject`, `issuer`.  Diese Ansprüche können auch direkt in den Nutzdaten mit `exp`, `nbf`, `aud`, `sub` bzw. `iss` angegeben werden, aber Sie **_können sie nicht_** an beiden Stellen einschließen.

Denken Sie daran, dass `exp`, `nbf` und `iat` ein **numerisches Datum** haben. Mehr dazu erfahren Sie unter [Tokenablauf (exp-Anspruch)](#token-expiration-exp-claim).


Der Header kann über das `options.header`-Objekt angepasst werden.

Generierte JSON-Webtoken (JWTs) enthalten standardmäßig einen `iat`-Anspruch (ausgestellt am), es sei denn, `noTimestamp` wird angegeben. Bei Einfügen von `iat` in die Nutzdaten wird dies anstelle des tatsächlichen Zeitstempels für die Berechnung anderer Aspekte wie `exp` verwendet, sofern in `options.expiresIn` eine Zeitspanne angegeben ist.

Synchrones Signieren mit Standard (HMAC SHA256)

```js
var jwt = require('jsonwebtoken');
var token = jwt.sign({ foo: 'bar' }, 'shhhhh');
```

Synchrones Signieren mit RSA SHA256
```js
// sign with RSA SHA256
var privateKey = fs.readFileSync('private.key');
var token = jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256'});
```

Asynchrones Signieren
```js
jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' }, function(err, token) {
  console.log(token);
});
```

Rückdatieren eines JSON-Webtoken (JWT) um 30 Sekunden
```js
var older_token = jwt.sign({ foo: 'bar', iat: Math.floor(Date.now() / 1000) - 30 }, 'shhhhh');
```

#### <a name="token-expiration-exp-claim"></a>Tokenablauf (exp-Anspruch)

Der Standard für JWT definiert einen `exp`-Anspruch für den Ablauf. Der Ablauf wird als **numerisches Datum** dargestellt:

> Ein numerischer JSON-Wert, der die Anzahl der Sekunden vom 1970-01-01T00:00:00Z UTC bis zum angegebenen UTC-Datum samt Uhrzeit angibt, wobei Schaltsekunden ignoriert werden.  Dies entspricht dem IEEE-Standard 1003.1, 2013 Edition [POSIX.1] für die Definition „Sekunden seit der Epoche“, bei der jeder Tag mit genau 86.400 Sekunden berücksichtigt wird, wobei auch nicht ganzzahlige Werte dargestellt werden können.  Details in Bezug auf Datum/Uhrzeit im Allgemeinen und UTC im Besonderen finden Sie der Dokumentation zu RFC 3339 [RFC3339].

Das bedeutet, dass das Feld `exp` die Anzahl der Sekunden seit der Epoche enthalten sollte.

Signieren eines Tokens mit einstündigem Ablauf:

```javascript
jwt.sign({
  exp: Math.floor(Date.now() / 1000) + (60 * 60),
  data: 'foobar'
}, 'secret');
```

Eine andere Möglichkeit, ein Token wie dieses mit dieser Bibliothek zu generieren, ist wie folgt:

```javascript
jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: 60 * 60 });

//or even better:

jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: '1h' });
```

### <a name="jwtverifytoken-secretorpublickey-options-callback"></a>jwt.verify(token, secretOrPublicKey, [options, callback])

(Asynchron) Wenn ein Rückruf bereitgestellt wird, arbeitet die Funktion asynchron. Der Rückruf wird mit den decodierten Nutzdaten aufgerufen, wenn die Signatur gültig ist und optional Ablaufdatum, Zielgruppe oder Aussteller gültig sind. Falls nicht, wird er mit dem Fehler aufgerufen.

(Synchron) Wenn kein Rückruf bereitgestellt wird, arbeitet die Funktion synchron. Gibt die Nutzdaten decodiert zurück, wenn die Signatur gültig ist und optional Ablaufdatum, Zielgruppe oder Aussteller gültig sind. Falls nicht, wird der Fehler ausgelöst.

`token` ist die JsonWebToken-Zeichenfolge.

`secretOrPublicKey` ist eine Zeichenfolge oder ein Puffer, die/der entweder das Geheimnis für HMAC-Algorithmen oder den PEM-codierten öffentlichen Schlüssel für RSA und ECDSA enthält.
Wenn `jwt.verify` asynchron aufgerufen wird, kann `secretOrPublicKey` eine Funktion sein, die den geheimen oder öffentlichen Schlüssel abrufen soll. Nachstehend finden Sie ein detailliertes Beispiel.

Wie in [diesem Kommentar](https://github.com/auth0/node-jsonwebtoken/issues/208#issuecomment-231861138) erwähnt, gibt es andere Bibliotheken, die Base64-codierte Geheimnisse erwarten (mit Base64 codierte zufällige Bytes). Wenn das bei Ihnen der Fall ist, können Sie `Buffer.from(secret, 'base64')` übergeben, wodurch das Geheimnis mit Base64 decodiert wird und für die Überprüfung des Tokens die ursprünglichen zufälligen Bytes verwendet werden.

`options`

* `algorithms`: Liste der Zeichenfolgen mit den Namen der zulässigen Algorithmen. Beispielsweise `["HS256", "HS384"]`.
* `audience`: Wenn Sie die Zielgruppe überprüfen möchten (`aud`), geben Sie hier einen Wert an. Die Zielgruppe kann mit einer Zeichenfolge, einem regulären Ausdruck oder einer Liste von Zeichenfolgen und/oder regulären Ausdrücken abgeglichen werden. 
  > Beispiel: `"urn:foo"`, `/urn:f[o]{2}/`, `[/urn:f[o]{2}/, "urn:bar"]`
* `complete`: gibt ein Objekt mit decodierten `{ payload, header, signature }` zurück, anstatt nur den üblichen Inhalt der Nutzdaten.
* `issuer` (optional): Zeichenfolge oder Array mit gültigen Werten für das Feld `iss`.
* `ignoreExpiration`: falls `true`, lassen Sie den Ablauf des Tokens nicht überprüfen.
* `ignoreNotBefore`...
* `subject`: Wenn Sie den Antragsteller überprüfen möchten (`sub`), geben Sie hier einen Wert an.
* `clockTolerance`: Anzahl der Sekunden, die bei der Überprüfung der Ansprüche `nbf` und `exp` toleriert werden, um kleine Taktunterschiede zwischen verschiedenen Servern zu berücksichtigen
* `maxAge`: das maximal zulässige Alter, in dem Token noch gültig sind. Es wird in Sekunden oder einer Zeichenfolge ausgedrückt, die eine Zeitspanne beschreibt [zeit/ms](https://github.com/zeit/ms). 
  > Beispiel: `1000`, `"2 days"`, `"10h"`, `"7d"`. Ein numerischer Wert wird als Sekundenanzahl interpretiert. Wenn Sie eine Zeichenfolge verwenden, stellen Sie sicher, dass Sie die Zeiteinheiten angeben (Tage, Stunden usw.). Andernfalls wird standardmäßig die Einheit Millisekunden verwendet (`"120"` gleich `"120ms"`).
* `clockTimestamp`: die Zeit in Sekunden, die als aktuelle Zeit für alle notwendigen Vergleiche verwendet werden soll.
* `nonce`: Wenn Sie den `nonce`-Anspruch prüfen möchten, geben Sie hier einen Zeichenfolgenwert an. Es wird in Open ID für die ID-Token verwendet. ([Hinweise zur Open ID-Implementierung](https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes))


```js
// verify a token symmetric - synchronous
var decoded = jwt.verify(token, 'shhhhh');
console.log(decoded.foo) // bar

// verify a token symmetric
jwt.verify(token, 'shhhhh', function(err, decoded) {
  console.log(decoded.foo) // bar
});

// invalid token - synchronous
try {
  var decoded = jwt.verify(token, 'wrong-secret');
} catch(err) {
  // err
}

// invalid token
jwt.verify(token, 'wrong-secret', function(err, decoded) {
  // err
  // decoded undefined
});

// verify a token asymmetric
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, function(err, decoded) {
  console.log(decoded.foo) // bar
});

// verify audience
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo' }, function(err, decoded) {
  // if audience mismatch, err == invalid audience
});

// verify issuer
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer' }, function(err, decoded) {
  // if issuer mismatch, err == invalid issuer
});

// verify jwt id
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid' }, function(err, decoded) {
  // if jwt id mismatch, err == invalid jwt id
});

// verify subject
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid', subject: 'subject' }, function(err, decoded) {
  // if subject mismatch, err == invalid subject
});

// alg mismatch
var cert = fs.readFileSync('public.pem'); // get public key
jwt.verify(token, cert, { algorithms: ['RS256'] }, function (err, payload) {
  // if token alg != RS256,  err == invalid signature
});

// Verify using getKey callback
// Example uses https://github.com/auth0/node-jwks-rsa as a way to fetch the keys.
var jwksClient = require('jwks-rsa');
var client = jwksClient({
  jwksUri: 'https://sandrino.auth0.com/.well-known/jwks.json'
});
function getKey(header, callback){
  client.getSigningKey(header.kid, function(err, key) {
    var signingKey = key.publicKey || key.rsaPublicKey;
    callback(null, signingKey);
  });
}

jwt.verify(token, getKey, options, function(err, decoded) {
  console.log(decoded.foo) // bar
});

```

### <a name="jwtdecodetoken--options"></a>jwt.decode(token [, options])

(Synchron) Gibt die decodierte Nutzlast zurück, ohne zu überprüfen, ob die Signatur gültig ist.

> __Warnung:__ Hierbei wird __nicht__ überprüft, ob die Signatur gültig ist. Sie sollten dies __nicht__ für nicht vertrauenswürdige Nachrichten verwenden. Stattdessen sollten Sie `jwt.verify` verwenden.

`token` ist die JsonWebToken-Zeichenfolge.

`options`:

* `json`: erzwingt JSON.parse für die Nutzdaten, auch wenn der Header nicht `"typ":"JWT"` enthält.
* `complete`: gibt ein Objekt mit decodierten Nutzdaten und Header zurück.

Beispiel

```js
// get the decoded payload ignoring signature, no secretOrPrivateKey needed
var decoded = jwt.decode(token);

// get the decoded payload and header
var decoded = jwt.decode(token, {complete: true});
console.log(decoded.header);
console.log(decoded.payload)
```

## <a name="errors--codes"></a>Fehler und Codes
Mögliche bei der Überprüfung ausgelöste Fehler.
„Error“ ist das erste Argument des Überprüfungsrückrufs.

### <a name="tokenexpirederror"></a>TokenExpiredError

Bei Ablauf des Tokens wird ein Fehler ausgelöst.

Error-Objekt:

* name: 'TokenExpiredError'
* message: 'jwt abgelaufen'
* expiredAt: [ExpDate]

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'TokenExpiredError',
        message: 'jwt expired',
        expiredAt: 1408621000
      }
    */
  }
});
```

### <a name="jsonwebtokenerror"></a>JsonWebTokenError
Error-Objekt:

* name: 'JsonWebTokenError'
* :
  * 'jwt nicht wohlgeformt'
  * 'jwt-Signatur erforderlich'
  * 'Ungültige Signatur'
  * 'jwt-Zielgruppe ungültig. erwartet: [OPTIONS AUDIENCE]'
  * 'JWT-Aussteller ungültig. erwartet: [OPTIONS ISSUER]'
  * 'JWT-ID ungültig. erwartet: [OPTIONS JWT ID]'
  * 'jwt-Antragsteller ungültig. erwartet: [OPTIONS SUBJECT]'

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'JsonWebTokenError',
        message: 'jwt malformed'
      }
    */
  }
});
```

### <a name="notbeforeerror"></a>NotBeforeError
Wird ausgelöst, wenn die aktuelle Uhrzeit vor dem nbf-Anspruch liegt.

Error-Objekt:

* name: 'NotBeforeError'
* Meldung: 'jwt nicht aktiv'
* date: 2018-10-04T16:10:44.000Z

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'NotBeforeError',
        message: 'jwt not active',
        date: 2018-10-04T16:10:44.000Z
      }
    */
  }
});
```


## <a name="algorithms-supported"></a>Unterstützte Algorithmen

Array der unterstützten Algorithmen. Die folgenden Algorithmen werden zurzeit unterstützt.

alg-Parameterwert | Digitaler Signatur- oder MAC-Algorithmus
----------------|----------------------------
HS256 | HMAC mit dem SHA-256-Hashalgorithmus
HS384 | HMAC mit dem SHA-384-Hashalgorithmus
HS512 | HMAC mit dem SHA-512-Hashalgorithmus
RS256 | RSASSA-PKCS1-v1_5 mit dem SHA-256-Hashalgorithmus
RS384 | RSASSA-PKCS1-v1_5 mit dem SHA-384-Hashalgorithmus
RS512 | RSASSA-PKCS1-v1_5 mit dem SHA-512-Hashalgorithmus
PS256 | RSASSA-PSS mit dem SHA-256-Hashalgorithmus (nur node ^6.12.0 6.12.0 ODER >=8.0.0)
PS384 | RSASSA-PSS mit dem SHA-384-Hashalgorithmus (nur node ^6.12.0 6.12.0 ODER >=8.0.0)
PS512 | RSASSA-PSS mit dem SHA-512-Hashalgorithmus (nur node ^6.12.0 6.12.0 ODER >=8.0.0)
ES256 | ECDSA mit P-256-Kurve und SHA-256-Hashalgorithmus
ES384 | ECDSA mit P-384-Kurve und SHA-384-Hashalgorithmus
ES512 | ECDSA mit P-512-Kurve und SHA-521-Hashalgorithmus
Keine | Kein digitaler Signatur- oder MAC-Wert enthalten

## <a name="refreshing-jwts"></a>Aktualisieren von JWTs

Zunächst empfehlen wir Ihnen, sorgfältig zu prüfen, ob die automatische Aktualisierung eines JWT kein Sicherheitsrisiko für Ihr System darstellt.

Wir sind nicht geneigt, dies in die Bibliothek aufzunehmen, aber Sie können einen Blick auf [das Beispiel](https://gist.github.com/ziluvatar/a3feb505c4c0ec37059054537b38fc48) werfen, um zu sehen, wie dies erreicht werden könnte.
Abgesehen von diesem Beispiel gibt es [ein Issue](https://github.com/auth0/node-jsonwebtoken/issues/122) und [einen Pull Request](https://github.com/auth0/node-jsonwebtoken/pull/172), um mehr über dieses Thema zu erfahren.

# <a name="todo"></a>TODO

* X.509-Zertifikatskette wird nicht überprüft

## <a name="issue-reporting"></a> Problemberichte 

Wenn Sie einen Fehler gefunden haben oder ein Feature wünschen, melden Sie dies im Abschnitt „Issues“ des Repositorys. Melden Sie keine Sicherheitsrisiken über den öffentlichen GitHub Issue Tracker. Im [Responsible Disclosure Program](https://auth0.com/whitehat) ist das Verfahren zur Offenlegung von Sicherheitsproblemen detailliert beschrieben.

## <a name="author"></a>Autor

[Auth0](https://auth0.com)

## <a name="license"></a>Lizenz

Dieses Projekt ist unter der MIT-Lizenz lizenziert. Weitere Informationen finden Sie in der Datei [LICENSE](LICENSE).
