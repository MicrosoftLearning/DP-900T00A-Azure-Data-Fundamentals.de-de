---
ms.openlocfilehash: cbc289a6b02d7acb0ad82e3a95bde8846fcff55e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050991"
---
# <a name="node-jws-build-statushttptravis-ciorgbrianloveswordsnode-jws"></a>node-jws [![Buildstatus](https://secure.travis-ci.org/brianloveswords/node-jws.png)](http://travis-ci.org/brianloveswords/node-jws)

Eine Implementierung von [JSON-Websignaturen](http://self-issued.info/docs/draft-ietf-jose-json-web-signature.html).

Diese wurde mit `draft-ietf-jose-json-web-signature-08` entwickelt und implementiert die gesamte Spezifikation **mit Ausnahme** der X.509-Vertrauenskettensignatur/-überprüfung (Patches willkommen).

Es gibt sowohl synchrone (`jws.sign`, `jws.verify`) als auch Streaming (`jws.createSign`, `jws.createVerify`)-APIs.

# <a name="install"></a>Installieren

```bash
$ npm install jws
```

# <a name="usage"></a>Verbrauch

## <a name="jwsalgorithms"></a>jws.ALGORITHMS

Array der unterstützten Algorithmen. Die folgenden Algorithmen werden zurzeit unterstützt.

alg-Parameterwert | Digitaler Signatur- oder MAC-Algorithmus
----------------|----------------------------
HS256 | HMAC mit dem SHA-256-Hashalgorithmus
HS384 | HMAC mit dem SHA-384-Hashalgorithmus
HS512 | HMAC mit dem SHA-512-Hashalgorithmus
RS256 | RSASSA mit dem SHA-256-Hashalgorithmus
RS384 | RSASSA mit dem SHA-384-Hashalgorithmus
RS512 | RSASSA mit dem SHA-512-Hashalgorithmus
PS256 | RSASSA-PSS mit dem SHA-256-Hashalgorithmus
PS384 | RSASSA-PSS mit dem SHA-384-Hashalgorithmus
PS512 | RSASSA-PSS mit dem SHA-512-Hashalgorithmus
ES256 | ECDSA mit P-256-Kurve und SHA-256-Hashalgorithmus
ES384 | ECDSA mit P-384-Kurve und SHA-384-Hashalgorithmus
ES512 | ECDSA mit P-512-Kurve und SHA-521-Hashalgorithmus
Keine | Kein digitaler Signatur- oder MAC-Wert enthalten

## <a name="jwssignoptions"></a>jws.sign(Optionen)

(Synchron) Zurückgeben einer JSON-Websignatur für einen Header und eine Nutzlast.

Optionen:

* `header`
* `payload`
* `secret` oder `privateKey`
* `encoding` (Optional, Standardwert ist „utf8“)

`header` muss ein Objekt mit einer `alg`-Eigenschaft sein. `header.alg` muss ein in `jws.ALGORITHMS` gefundener Wert sein. Eine Tabelle mit unterstützten Algorithmen finden sie weiter oben.

Wenn `payload` kein Puffer oder eine Zeichenfolge ist, wird er mit `JSON.stringify` in eine Zeichenfolge gezwungen.

Beispiel

```js
const signature = jws.sign({
  header: { alg: 'HS256' },
  payload: 'h. jon benjamin',
  secret: 'has a van',
});
```

## <a name="jwsverifysignature-algorithm-secretorkey"></a>jws.verify(Signatur, Algorithmus, GeheimnisOderSchlüssel)

(Synchron) Gibt `true` oder `false` dafür zurück, ob eine Signatur einem Geheimnis oder Schlüssel entspricht.

`signature` ist eine JWS-Signatur. `header.alg` muss ein in `jws.ALGORITHMS` gefundener Wert sein.
Eine Tabelle mit unterstützten Algorithmen finden sie weiter oben. `secretOrKey` ist eine Zeichenfolge oder ein Puffer, die/der entweder das Geheimnis für HMAC-Algorithmen oder den PEM-codierten öffentlichen Schlüssel für RSA und ECDSA enthält.

Beachten Sie, dass der `"alg"`-Wert aus dem Signaturheader ignoriert wird.


## <a name="jwsdecodesignature"></a>jws.decode(Signatur)

(Synchron) Gibt den decodierten Header, die decodierte Nutzlast und Signaturteile der JWS-Signatur zurück.

Gibt ein Objekt mit drei Eigenschaften zurück, z. B.
```js
{ header: { alg: 'HS256' },
  payload: 'h. jon benjamin',
  signature: 'YOWPewyGHKu4Y_0M_vtlEnNlqmFOclqp4Hy6hVHfFT4'
}
```

## <a name="jwscreatesignoptions"></a>jws.createSign(Optionen)

Gibt ein neues SignStream-Objekt zurück.

Optionen:

* `header` (erforderlich)
* `payload`
* `key` || `privateKey` || `secret`
* `encoding` (Optional, Standardwert ist „utf8“)

Anders als `header`, erwarten alle Optionen eine Zeichenfolge oder einen Puffer, wenn der Wert vor der Zeit bekannt ist, oder einen Stream aus Bequemlichkeit.
`key`/`privateKey`/`secret` kann auch ein Objekt sein, wenn ein verschlüsselter privater Schlüssel verwendet wird. Siehe die [Kryptodokumentation][encrypted-key-docs].

Beispiel:

```js

// This...
jws.createSign({
  header: { alg: 'RS256' },
  privateKey: privateKeyStream,
  payload: payloadStream,
}).on('done', function(signature) {
  // ...
});

// is equivalent to this:
const signer = jws.createSign({
  header: { alg: 'RS256' },
});
privateKeyStream.pipe(signer.privateKey);
payloadStream.pipe(signer.payload);
signer.on('done', function(signature) {
  // ...
});
```

## <a name="jwscreateverifyoptions"></a>jws.createVerify(Optionen)

Gibt ein neues VerifyStream-Objekt zurück.

Optionen:

* `signature`
* `algorithm`
* `key` || `publicKey` || `secret`
* `encoding` (Optional, Standardwert ist „utf8“)

Alle Optionen erwarten eine Zeichenfolge oder einen Puffer, wenn der Wert vor der Zeit bekannt ist, oder einen Stream aus Bequemlichkeit.

Beispiel:

```js

// This...
jws.createVerify({
  publicKey: pubKeyStream,
  signature: sigStream,
}).on('done', function(verified, obj) {
  // ...
});

// is equivilant to this:
const verifier = jws.createVerify();
pubKeyStream.pipe(verifier.publicKey);
sigStream.pipe(verifier.signature);
verifier.on('done', function(verified, obj) {
  // ...
});
```

## <a name="class-signstream"></a>Klasse: SignStream

Ein `Readable Stream`, der nach Abschluss ein einzelnes Datenereignis (die berechnete Signatur) ausgibt.

### <a name="event-done"></a>Ereignis: „done“ (fertig)
`function (signature) { }`

### <a name="signerpayload"></a>signer.payload

Ein `Writable Stream`, der die JWS-Nutzlast erwartet. *Nicht* verwenden, wenn Sie eine `payload`-Option an den Konstruktor übergeben haben.

Beispiel:

```js
payloadStream.pipe(signer.payload);
```

### <a name="signersecretbrsignerkeybrsignerprivatekey"></a>signer.secret<br>signer.key<br>signer.privateKey

einen `Writable Stream` Erwartet das JWS-Geheimnis für HMAC oder den privaten Schlüssel (privateKey) für ECDSA und RSA. *Nicht* verwenden, wenn Sie eine `secret`- oder `key`-Option an den Konstruktor übergeben haben.

Beispiel:

```js
privateKeyStream.pipe(signer.privateKey);
```

## <a name="class-verifystream"></a>Klasse: VerifyStream

Dies ist ein `Readable Stream`, der ein einzelnes Datenereignis ausgibt – das Ergebnis, ob diese Signatur gültig war oder nicht.

### <a name="event-done"></a>Ereignis: „done“ (fertig)
`function (valid, obj) { }`

`valid` ist ein boolescher Wert dafür, ob die Signatur gültig ist oder nicht.

### <a name="verifiersignature"></a>verifier.signature

Ein `Writable Stream`, der eine JWS-Signatur erwartet. *Nicht* verwenden, wenn Sie eine `signature`-Option an den Konstruktor übergeben haben.

### <a name="verifiersecretbrverifierkeybrverifierpublickey"></a>verifier.secret<br>verifier.key<br>verifier.publicKey

Ein `Writable Stream`, der einen öffentlichen Schlüssel oder ein Geheimnis erwartet. *Nicht* verwenden, wenn Sie eine `key`- oder `secret`-Option an den Konstruktor übergeben haben.

# <a name="todo"></a>TODO

* Es sieht so aus, als ob es einige Komfortoptionen/APIs zum Definieren des Algorithmus geben sollte, anstatt jedes Mal ein Headerobjekt mit `{ alg: 'ES512' }` oder was auch immer definieren zu müssen.

* X.509-Unterstützung, oder?

# <a name="license"></a>Lizenz

MIT

```
Copyright (c) 2013-2015 Brian J. Brennan

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

[encrypted-key-docs]: https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format
