---
ms.openlocfilehash: 6e78f9de8f21b6501e007e86f631942016f041dc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051263"
---
# <a name="jsbi--pure-javascript-bigints-build-statushttpstravis-cicomgooglechromelabsjsbi-jsbi-on-npmhttpswwwnpmjscompackagejsbi"></a>JSBI – reine JavaScript BigInts [![Buildstatus](https://travis-ci.com/GoogleChromeLabs/jsbi.svg?branch=main)](https://travis-ci.com/GoogleChromeLabs/jsbi)[![jsbi auf npm](https://img.shields.io/npm/v/jsbi)](https://www.npmjs.com/package/jsbi)

JSBI ist eine reine JavaScript-Implementierung des [ECMAScript BigInt-Vorschlags](https://tc39.es/proposal-bigint/), der offiziell Teil der JavaScript-Sprache in ES2020 wurde.

## <a name="installation"></a>Installation

```sh
npm install jsbi --save
```

## <a name="usage"></a>Verbrauch

```js
import JSBI from './jsbi.mjs';

const max = JSBI.BigInt(Number.MAX_SAFE_INTEGER);
console.log(String(max));
// → '9007199254740991'
const other = JSBI.BigInt('2');
const result = JSBI.add(max, other);
console.log(String(result));
// → '9007199254740993'
```

Hinweis: Rufen Sie `toString` explizit für alle `JSBI`-Instanzen auf, wenn Sie sie per `console.log()` protokollieren, um ihre numerische Darstellung zu ermitteln (z. B. `String(max)` oder `max.toString()`). Ohne dies (z. B. `console.log(max)`) wird stattdessen das Objekt angezeigt, das den Wert darstellt.

Verwenden Sie [babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint), um JSBI-Code in nativen BigInt-Code zu transpilieren.

Weitere Informationen finden Sie in den nachstehenden detaillierten Anweisungen.

## <a name="why"></a>Warum?

[Native BigInts werden bereits ausgeliefert](https://v8.dev/features/bigint) in modernen Browsern (zum Zeitpunkt dieser Niederschrift Google Chrome 67+, Opera 54+, Firefox 68+) und in Node.js (v10.4+), und sie werden voraussichtlich in Zukunft noch in anderen Browsern verfügbar – was bedeutet, dass Sie sie noch nicht verwenden können, wenn Ihr Code überall ausgeführt werden können soll.

Um BigInts heute in Ihrem Code zu verwenden, benötigen Sie eine Bibliothek. Aber hier liegt eine Schwierigkeit: Der BigInt-Vorschlag ändert das Verhalten von Operatoren (z. B. `+`, `>=` usw.) zur Bearbeitung von BigInts. Diese Änderungen lassen sich unmöglich direkt mit einem Polyfill versehen. Außerdem machen sie es (in den meisten Fällen) unmöglich, BigInt-Code mit Babel oder ähnlichen Tools in Fallbackcode zu transpilieren. Der Grund dafür ist, dass eine solche Transpilierung jeden einzelnen Operator im Programm durch einen Aufruf einer Funktion ersetzen müsste, die Typüberprüfungen für die Eingaben des Operators durchführt, was zu einer inakzeptablen Leistungsbeeinträchtigung führen würde.

Die Lösung besteht darin, es genau andersherum zu machen: Schreiben von Code mithilfe der Syntax einer Bibliothek und [Transpilieren dieses Codes in nativen BigInt-Code](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint), wenn verfügbar. JSBI ist für genau diesen Zweck konzipiert: Es bietet eine „Polyfill“-Implementierung von BigInt, die sich genau wie die bald verfügbaren nativen BigInts verhält, aber mit einer Syntax, die Sie schon heute in allen Browsern ausliefern können.

Die Vorteile gegenüber anderen, vorhandenen BigInt-Bibliotheken sind:

- Verhält sich genau wie native BigInts, wenn diese verfügbar werden. Um also zu diesen zu migrieren, können Sie die Syntax Ihres Codes [mechanisch](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) aktualisieren. Sie werden die Logik Ihres Codes nicht neu überdenken müssen.
- Starker Fokus auf Leistung. Im Durchschnitt ist JSBI mit der nativen Implementierung, die derzeit mit Google Chrome ausgeliefert wird, hinsichtlich der Leistung voll wettbewerbsfähig.

## <a name="how"></a>Wie kann ich das erreichen?

Außer bei mechanischen Unterschieden in der Syntax verwenden Sie JSBI-BigInts genau [wie native BigInts](https://developers.google.com/web/updates/2018/05/bigint). Einige Dinge sehen sogar gleich aus, nachdem Sie `BigInt` durch `JSBI.BigInt` ersetzt haben:

| Vorgang            | native BigInts          | JSBI                     |
| -------------------- | ----------------------- | ------------------------ |
| Erstellen aus Zeichenfolge | `a = BigInt('456')`     | `a = JSBI.BigInt('456')` |
| Erstellen aus Zahl | `a = BigInt(789)`       | `a = JSBI.BigInt(789)`   |
| Konvertierung in Zeichenfolge | `a.toString(radix)`     | `a.toString(radix)`      |
| Konvertierung in Zahl | `Number(a)`             | `JSBI.toNumber(a)`       |
| Abschneiden           | `BigInt.asIntN(64, a)`  | `JSBI.asIntN(64, a)`     |
|                      | `BigInt.asUintN(64, a)` | `JSBI.asUintN(64, a)`    |
| Typüberprüfung           | `typeof a === 'bigint'` | `a instanceof JSBI`      |

Die meisten Operatoren werden durch Methodenaufrufe ersetzt:

| Vorgang                   | native BigInts | JSBI                              |
| --------------------------- | -------------- | --------------------------------- |
| Addition                    | `c = a + b`    | `c = JSBI.add(a, b)`              |
| Subtraktion                 | `c = a - b`    | `c = JSBI.subtract(a, b)`         |
| Multiplikation              | `c = a * b`    | `c = JSBI.multiply(a, b)`         |
| Division                    | `c = a / b`    | `c = JSBI.divide(a, b)`           |
| Rest                   | `c = a % b`    | `c = JSBI.remainder(a, b)`        |
| Potenzierung              | `c = a ** b`   | `c = JSBI.exponentiate(a, b)`     |
| Negation                    | `b = -a`       | `b = JSBI.unaryMinus(a)`          |
| Bitweise Negation            | `b = ~a`       | `b = JSBI.bitwiseNot(a)`          |
| Linksverschiebung               | `c = a << b`   | `c = JSBI.leftShift(a, b)`        |
| Rechtsverschiebung              | `c = a >> b`   | `c = JSBI.signedRightShift(a, b)` |
| Bitweises AND               | `c = a & b`    | `c = JSBI.bitwiseAnd(a, b)`       |
| Bitweises OR                | `c = a \| b`   | `c = JSBI.bitwiseOr(a, b)`        |
| Bitweises XOR               | `c = a ^ b`    | `c = JSBI.bitwiseXor(a, b)`       |
| Vergleich mit anderen BigInts | `a === b`      | `JSBI.equal(a, b)`                |
|                             | `a !== b`      | `JSBI.notEqual(a, b)`             |
|                             | `a < b`        | `JSBI.lessThan(a, b)`             |
|                             | `a <= b`       | `JSBI.lessThanOrEqual(a, b)`      |
|                             | `a > b`        | `JSBI.greaterThan(a, b)`          |
|                             | `a >= b`       | `JSBI.greaterThanOrEqual(a, b)`   |

Die obigen Funktionen arbeiten nur mit BigInts. (Sie führen keine Typüberprüfungen in der aktuellen Implementierung durch, da solche Überprüfungen Zeitverschwendung sind, wenn wir davon ausgehen, dass Sie wissen, was Sie tun. Versuchen Sie nicht, sie mit anderen Eingaben aufzurufen, oder Sie werden „interessante“ Fehler erhalten!)

Einige Vorgänge sind besonders interessant, wenn Sie ihnen Eingaben gemischter Typen geben, z. B. das Vergleichen eines BigInt mit einer Zahl oder das Verketten einer Zeichenfolge mit einem BigInt. Sie sind als statische Funktionen implementiert, die nach den jeweiligen nativen Operatoren benannt sind:

| Vorgang                       | native BigInts | JSBI             |
| ------------------------------- | -------------- | ---------------- |
| Abstrakter Gleichheitsvergleich    | `x == y`       | `JSBI.EQ(x, y)`  |
| Generisches „ungleich“             | `x != y`       | `JSBI.NE(x, y)`  |
| Generisches „kleiner als“             | `x < y`        | `JSBI.LT(x, y)`  |
| Generisches „kleiner als oder gleich“    | `x <= y`       | `JSBI.LE(x, y)`  |
| Generisches „größer als“          | `x > y`        | `JSBI.GT(x, y)`  |
| Generisches „größer als oder gleich“ | `x >= y`       | `JSBI.GE(x, y)`  |
| Generische Addition                | `x + y`        | `JSBI.ADD(x, y)` |

Die Variablennamen `x` und `y` geben hier an, dass die Variablen auf alles verweisen können, z. B `JSBI.GT(101.5, BigInt('100'))` oder `str = JSBI.ADD('result: ', BigInt('0x2A'))`.

Leider gibt es auch einige Dinge, die gar nicht unterstützt werden:

| Nicht unterstützter Vorgang | native BigInts | JSBI                                 |
| --------------------- | -------------- | ------------------------------------ |
| Literale              | `a = 123n;`    | N/V ☹                                |
| increment             | `a++`          | N/V ☹                                |
|                       | `a + 1n`       | `JSBI.add(a, JSBI.BigInt('1'))`      |
| Dekrement             | `a--`          | N/V ☹                                |
|                       | `a - 1n`       | `JSBI.subtract(a, JSBI.BigInt('1'))` |

Es ist unmöglich, das genaue Verhalten der nativen Operatoren `++` und `--` mit statischen Funktionen zu replizieren. Da JSBI letztendlich sowieso für die Transpilierung konzipiert wurde, bietet es keine ähnliche, aber andere Alternative. Sie können stattdessen `JSBI.add()` und `JSBI.subtract()` verwenden.

## <a name="when"></a>Wann?

Jetzt! Die JSBI-Bibliothek ist heute schon einsatzbereit.

Sobald BigInts überall nativ unterstützt werden, verwenden Sie [babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint), um Ihren JSBI-Code ein für alle Mal in nativen BigInt-Code zu transpilieren.

Weitere Informationen zu unseren zukünftigen Plänen für JSBI finden Sie in [unserer Problemverfolgung](https://github.com/GoogleChromeLabs/jsbi/issues). Nehmen Sie außerdem an der Diskussion teil!

Ein eher vager Plan für die Zukunft besteht darin, die JSBI-Bibliothek (oder eine Erweiterung davon) als Staginggrundlage für zusätzliche BigInt-bezogene Funktionen zu verwenden. Der offizielle Vorschlag fällt absichtlich etwas minimalistisch aus und überlässt weitere „Bibliotheksfunktionen“ den nächsten Vorschlägen. Beispiele sind eine kombinierte `exp`+`mod`-Funktion und Bitbearbeitungsfunktionen.

## <a name="development"></a>Entwicklung

1. Klonen Sie dieses Repository, und wechseln Sie in das lokale Verzeichnis (`cd`).

1. Verwenden Sie die in `.nvmrc` angegebene Node.js-Version:

     ```sh
     nvm use
     ```

1. Installieren von Entwicklungsabhängigkeiten:

    ```sh
    npm install
    ```

1. Führen Sie die Tests aus:

    ```sh
    npm test
    ```

    Eine Liste der Befehle finden Sie unter `npm run`.

## <a name="for-maintainers"></a>Für Maintainer

### <a name="how-to-publish-a-new-release"></a>Veröffentlichen eines neuen Release

1. Verlegen Sie im `main`-Branch die Versionsnummer in `package.json`:

    ```sh
    npm version patch -m 'Release v%s'
    ```

    Verwenden Sie anstelle von `patch` [nach Bedarf](https://semver.org/) `minor` oder `major`.

    Beachten Sie, dass dies einen Git Commit + Tag erzeugt.

1. Pushen des Release-Commits und -Tags:

    ```sh
    git push
    ```

    Unsere CI veröffentlicht dann automatisch das neue Release in npm.
