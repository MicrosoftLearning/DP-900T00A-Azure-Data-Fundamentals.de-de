---
ms.openlocfilehash: 496981207a34eb019688e8f2583ccc1abcbb5bce
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050952"
---
<a name="semver1----the-semantic-versioner-for-npm"></a>SemVer(1) -- Die semantische Versionierung für npm
===========================================

## <a name="install"></a>Installieren

```bash
npm install --save semver
````

## <a name="usage"></a>Verbrauch

Als Knotenmodul:

```js
const semver = require('semver')

semver.valid('1.2.3') // '1.2.3'
semver.valid('a.b.c') // null
semver.clean('  =v1.2.3   ') // '1.2.3'
semver.satisfies('1.2.3', '1.x || >=2.5.0 || 5.0.0 - 7.2.3') // true
semver.gt('1.2.3', '9.8.7') // false
semver.lt('1.2.3', '9.8.7') // true
semver.minVersion('>=1.0.0') // '1.0.0'
semver.valid(semver.coerce('v2')) // '2.0.0'
semver.valid(semver.coerce('42.6.7.9.3-alpha')) // '42.6.7'
```

Als Befehlszeilen-Hilfsprogramm:

```
$ semver -h

A JavaScript implementation of the https://semver.org/ specification
Copyright Isaac Z. Schlueter

Usage: semver [options] <version> [<version> [...]]
Prints valid versions sorted by SemVer precedence

Options:
-r --range <range>
        Print versions that match the specified range.

-i --increment [<level>]
        Increment a version by the specified level.  Level can
        be one of: major, minor, patch, premajor, preminor,
        prepatch, or prerelease.  Default level is 'patch'.
        Only one version may be specified.

--preid <identifier>
        Identifier to be used to prefix premajor, preminor,
        prepatch or prerelease version increments.

-l --loose
        Interpret versions and ranges loosely

-p --include-prerelease
        Always include prerelease versions in range matching

-c --coerce
        Coerce a string into SemVer if possible
        (does not imply --loose)

Program exits successfully if any valid version satisfies
all supplied ranges, and prints all satisfying versions.

If no satisfying versions are found, then exits failure.

Versions are printed in ascending order, so supplying
multiple versions to the utility will just sort them.
```

## <a name="versions"></a>Versionen

Eine "Version" wird durch die `v2.0.0`-Spezifikation unter <https://semver.org/> beschrieben.

Ein vorangestelltes `"="`- oder `"v"`-Zeichen wird entfernt und ignoriert.

## <a name="ranges"></a>Bereiche

Ein `version range` ist eine Gruppe von `comparators`, in der Versionen angegeben werden, die die Bedingungen des Bereich erfüllen.

Ein `comparator` besteht aus einem `operator` und einer `version`.  Die Grundtypen der `operators` sind:

* `<` Kleiner als
* `<=` Kleiner als oder gleich
* `>` Größer als
* `>=` Größer als oder gleich
* `=` Gleich.  Wenn kein Operator angegeben wird, wird Gleichheit vorausgesetzt, sodass dieser Operator optional ist, aber einbezogen werden KANN.

Der Vergleichsoperator `>=1.2.7` würde z. B. mit den Versionen `1.2.7`, `1.2.8`, `2.5.3` and `1.3.9` übereinstimmen, aber nicht mit den Versionen `1.2.6` oder `1.1.0`.

Vergleichsoperatoren können mit Leerzeichen zu einem `comparator set` verknüpft werden, dessen Bedingungen durch die **Schnittmenge** aller enthaltenen Vergleichsoperatoren erfüllt werden.

Ein Bereich besteht aus einem oder mehreren Vergleichsoperatorsätzen, die durch `||` verknüpft sind.  Eine Version entspricht nur dann einem Bereich, wenn die Bedingungen jedes Vergleichsoperators in mindestens einem der durch `||` getrennten Vergleichsoperatorsätze von der Version erfüllt werden.

Der Bereich `>=1.2.7 <1.3.0` würde z. B. mit den Versionen `1.2.7`, `1.2.8` und `1.2.99` übereinstimmen, aber nicht mit den Versionen `1.2.6`, `1.3.0` oder `1.1.0`.

Der Bereich `1.2.7 || >=1.2.9 <2.0.0` würde mit den Versionen `1.2.7`, `1.2.9` und `1.4.6` übereinstimmen, aber nicht mit den Versionen `1.2.8` oder `2.0.0`.

### <a name="prerelease-tags"></a>Vorabversions-Tags

Wenn eine Version über ein Vorabversions-Tag (z. B. `1.2.3-alpha.3`) verfügt, können die Bedingungen des Vergleichsoperatorsatzes nur erfüllt sein, wenn mindestens ein Vergleichsoperator mit demselben `[major, minor, patch]` Tupel ebenfalls über ein Vorabversions-Tag verfügt.

Beispielsweise könnte der Bereich `>1.2.3-alpha.3` mit der Version `1.2.3-alpha.7`übereinstimmen, aber seine Bedingungen wären *nicht* durch `3.4.5-alpha.9` erfüllt, auch wenn `3.4.5-alpha.9` gemäß den SemVer-Sortierregeln technisch "größer als" `1.2.3-alpha.3` ist.  In dem Versionsbereich sind nur Vorabversions-Tags der Version `1.2.3` zulässig.  Die Version `3.4.5`*würde* die Bedingungen des Bereichs erfüllen, da sie kein Vorabversions-Flag hat und `3.4.5` größer als `1.2.3-alpha.7` ist.

Mit diesem Verhalten werden zwei Ziele verfolgt.  Zum einen werden Vorabversionen häufig sehr schnell aktualisiert und enthalten viele Breaking Changes, die (nach Vorstellung des Autors) noch nicht für die Öffentlichkeit geeignet sind.
Daher werden sie standardmäßig aus der Semantik des Bereichsabgleichs ausgeschlossen.

Zum anderen hat ein Benutzer, der sich für die Verwendung einer Vorabversion entschieden hat, seiner Absicht, *diese spezielle* Gruppe von Alpha/Beta/Rc-Versionen zu verwenden, klar und deutlich Ausdruck verliehen.  Indem der Benutzer ein Vorabversions-Tag in den Bereich einbezieht, gibt er an, dass er sich des Risikos bewusst ist.  Dennoch sollte nicht davon ausgegangen werden, dass er sich entschieden hat, ein ähnliches Risiko auch bei der *nächsten* Gruppe von Vorabversionen einzugehen.

Beachten Sie, dass dieses Verhalten unterdrückt werden kann (indem alle Vorabversionen für den Bereichsabgleich wie normale Versionen behandelt werden), indem Sie das `includePrerelease`-Flag für das Optionsobjekt auf beliebige [Funktionen](https://github.com/npm/node-semver#functions) festlegen, die einen Bereichsabgleich ausführen.

#### <a name="prerelease-identifiers"></a>Vorabversions-Bezeichner

Die Methode `.inc` erfordert ein zusätzliches `identifier`-Zeichenfolgenargument, bei dem der Wert der Zeichenfolge als Vorabversions-Bezeichner angefügt wird:

```javascript
semver.inc('1.2.3', 'prerelease', 'beta')
// '1.2.4-beta.0'
```

Befehlszeilenbeispiel:

```bash
$ semver 1.2.3 -i prerelease --preid beta
1.2.4-beta.0
```

Welches anschließend zum weiteren Inkrementieren verwendet werden kann:

```bash
$ semver 1.2.4-beta.0 -i prerelease
1.2.4-beta.1
```

### <a name="advanced-range-syntax"></a>Erweiterte Bereichssyntax

Die erweiterte Bereichssyntax wird auf entschlossene Art und Weise durch Desugaring in einfache Vergleichsoperatoren umgewandelt.

Erweiterte Bereiche können auf dieselbe Weise kombiniert werden wie einfache Vergleichsoperatoren, und zwar mithilfe von Leerzeichen oder `||`.

#### <a name="hyphen-ranges-xyz---abc"></a>Bindestrichbereiche `X.Y.Z - A.B.C`

Gibt einen inklusiven Satz an.

* `1.2.3 - 2.3.4` := `>=1.2.3 <=2.3.4`

Wenn eine Teilversion als erste Version in dem Inklusivbereich bereitgestellt wird, werden die fehlenden Teile durch Nullen ersetzt.

* `1.2 - 2.3.4` := `>=1.2.0 <=2.3.4`

Wenn eine Teilversion als zweite Version in dem Inklusivbereich bereitgestellt wird, werden alle Versionen, die mit den angegebenen Teilen des Tupels beginnen, akzeptiert, aber nichts, das größer wäre als die bereitgestellten Tupelteile.

* `1.2.3 - 2.3` := `>=1.2.3 <2.4.0`
* `1.2.3 - 2` := `>=1.2.3 <3.0.0`

#### <a name="x-ranges-12x-1x-12-"></a>X-Bereiche `1.2.x` `1.X` `1.2.*` `*`

Entweder `X`, `x` oder`*` kann anstelle eines der numerischen Werte im `[major, minor, patch]`-Tupel verwendet werden.

* `*` := `>=0.0.0` (Jede Version erfüllt die Bedingungen)
* `1.x` := `>=1.0.0 <2.0.0` (Zugehörige Hauptversion)
* `1.2.x` := `>=1.2.0 <1.3.0` (Zugehörige Haupt- und Nebenversion)

Ein Teilversionsbereich wird wie ein X-Bereich behandelt, sodass das Sonderzeichen tatsächlich optional ist.

* `""` (leere Zeichenfolge) := `*` := `>=0.0.0`
* `1` := `1.x.x` := `>=1.0.0 <2.0.0`
* `1.2` := `1.2.x` := `>=1.2.0 <1.3.0`

#### <a name="tilde-ranges-123-12-1"></a>Tilde-Bereiche `~1.2.3``~1.2``~1`

Ermöglicht Änderungen auf Patchebene, wenn in dem Vergleichsoperator eine Nebenversion angegeben ist.  Ermöglicht andernfalls Änderungen auf untergeordneter Ebene.

* `~1.2.3` := `>=1.2.3 <1.(2+1).0` := `>=1.2.3 <1.3.0`
* `~1.2` := `>=1.2.0 <1.(2+1).0` := `>=1.2.0 <1.3.0` (Identisch mit `1.2.x`)
* `~1` := `>=1.0.0 <(1+1).0.0` := `>=1.0.0 <2.0.0` (Identisch mit `1.x`)
* `~0.2.3` := `>=0.2.3 <0.(2+1).0` := `>=0.2.3 <0.3.0`
* `~0.2` := `>=0.2.0 <0.(2+1).0` := `>=0.2.0 <0.3.0` (Identisch mit `0.2.x`)
* `~0` := `>=0.0.0 <(0+1).0.0` := `>=0.0.0 <1.0.0` (Identisch mit `0.x`)
* `~1.2.3-beta.2` := `>=1.2.3-beta.2 <1.3.0` Beachten Sie, dass Vorabversionen in der Version `1.2.3` zulässig sind, wenn sie größer als oder gleich `beta.2` sind.  Somit wäre `1.2.3-beta.4` zulässig, `1.2.4-beta.2` jedoch nicht, da es sich um eine Vorabversion eines anderen `[major, minor, patch]` Tupels handelt.

#### <a name="caret-ranges-123-025-004"></a>Textcursor-Bereiche `^1.2.3``^0.2.5``^0.0.4`

Ermöglicht Änderungen, durch welche die Ziffern ganz links in dem `[major, minor, patch]` Tupel, die nicht gleich null sind, nicht geändert werden.  Mit anderen Worten sind Patch- und kleinere Updates für Versionen ab Version `1.0.0`, Patch-Updates für `0.X >=0.1.0`-Versionen, aber *keine* Updates für `0.0.X`-Versionen zulässig.

Viele Autoren behandeln eine `0.x`-Version so, als ob `x` der wichtigste „Breaking Change“-Indikator wäre.

Textcursor-Bereiche sind ideal, wenn Breaking Changes zwischen den Versionen `0.2.4` und `0.3.0` vorgenommen werden sollen, was häufig der Fall ist.
Es wird jedoch davon ausgegangen, dass es *keine* Breaking Changes zwischen `0.2.4` und `0.2.5` geben wird.  Ermöglicht werden Änderungen, bei denen davon ausgegangen wird, dass sie, wie häufig zu beobachten, additiv (aber keine Breaking Changes) sind.

* `^1.2.3` := `>=1.2.3 <2.0.0`
* `^0.2.3` := `>=0.2.3 <0.3.0`
* `^0.0.3` := `>=0.0.3 <0.0.4`
* `^1.2.3-beta.2` := `>=1.2.3-beta.2 <2.0.0` Beachten Sie, dass Vorabversionen in der Version `1.2.3` zulässig sind, wenn sie größer als oder gleich `beta.2` sind.  Somit wäre `1.2.3-beta.4` zulässig, `1.2.4-beta.2` jedoch nicht, da es sich um eine Vorabversion eines anderen `[major, minor, patch]` Tupels handelt.
* `^0.0.3-beta` := `>=0.0.3-beta <0.0.4` Beachten Sie, dass Vorabversionen in der Version `0.0.3` *nur* zulässig sind, wenn sie größer als oder gleich `beta` sind.  Also wäre `0.0.3-pr.2` zulässig.

Beim Parsen von Textcursor-Bereichen wird ein fehlender `patch`-Wert durch Desugaring in die Zahl `0` umgewandelt. Innerhalb dieses Werts ist Flexibilität jedoch zulässig, auch wenn die Haupt- und Nebenversionen beide `0` sind.

* `^1.2.x` := `>=1.2.0 <2.0.0`
* `^0.0.x` := `>=0.0.0 <0.1.0`
* `^0.0` := `>=0.0.0 <0.1.0`

Fehlende `minor`- und `patch`-Werte werden in null umgewandelt. Auch innerhalb dieser Werte ist Flexibilität zulässig, auch wenn die Hauptversion null ist.

* `^1.x` := `>=1.0.0 <2.0.0`
* `^0.x` := `>=0.0.0 <1.0.0`

### <a name="range-grammar"></a>Bereichsgrammatik

All dies zusammengenommen finden Sie hier eine Backus-Naur- Grammatik für Bereiche, von der Parser-Autoren profitieren:

```bnf
range-set  ::= range ( logical-or range ) *
logical-or ::= ( ' ' ) * '||' ( ' ' ) *
range      ::= hyphen | simple ( ' ' simple ) * | ''
hyphen     ::= partial ' - ' partial
simple     ::= primitive | partial | tilde | caret
primitive  ::= ( '<' | '>' | '>=' | '<=' | '=' ) partial
partial    ::= xr ( '.' xr ( '.' xr qualifier ? )? )?
xr         ::= 'x' | 'X' | '*' | nr
nr         ::= '0' | ['1'-'9'] ( ['0'-'9'] ) *
tilde      ::= '~' partial
caret      ::= '^' partial
qualifier  ::= ( '-' pre )? ( '+' build )?
pre        ::= parts
build      ::= parts
parts      ::= part ( '.' part ) *
part       ::= nr | [-0-9A-Za-z]+
```

## <a name="functions"></a>Functions

Alle Methoden und Klassen benötigen ein endgültiges `options` Objektargument.  Alle Optionen in diesem Objekt sind standardmäßig `false`.  Folgende Optionen werden unterstützt:

- `loose`  Mehr Toleranz gegenüber nicht ganz gültigen SemVer-Zeichenfolgen.
  (Alle Ausgaben müssen natürlich immer zu 100 % konform sein.)  Aus Gründen der Abwärtskompatibilität wird das Argument `options`, wenn es sich um einen Booleschen Wert und nicht um ein Objekt handelt, als `loose` Parameter interpretiert.
- `includePrerelease` Festlegen, um das [Standardverhalten](https://github.com/npm/node-semver#prerelease-tags) beim Ausschließen markierter Vorabversionen aus bestimmten Bereichen zu unterdrücken, sofern sie nicht ausdrücklich aktiviert wurden.

Strict-Modus-Vergleichsoperatoren und -Bereiche sind streng, was die SemVer-Zeichenfolgen anbelangt, die sie parsen.

* `valid(v)`: Gibt die geparste Version oder null zurück, wenn sie ungültig ist.
* `inc(v, release)`: Gibt die Version zurück, die durch den Versionstyp (`major`,   `premajor`, `minor`, `preminor`, `patch`, `prepatch` oder `prerelease`) erhöht wird, oder null, wenn dieser nicht gültig ist.
  * `premajor` In einem Aufruf wird die Version bis zur nächsten Hauptversion und bis zu einer Vorabversion dieser Hauptversion aktualisiert.
    `preminor` und `prepatch` funktionieren identisch.
  * Wenn sie von einer Version ohne Vorabversion aufgerufen wird, funktioniert die `prerelease` genauso wie das `prepatch`. Sie erhöht die Patchversion und erstellt dann eine Vorabversion. Wenn die Eingabeversion bereits eine Vorabversion ist, wird sie einfach erhöht.
* `prerelease(v)`: Gibt ein Array von Vorabkomponenten oder null zurück, wenn keine vorhanden sind. Beispiel: `prerelease('1.2.3-alpha.1') -> ['alpha', 1]`
* `major(v)`: Gibt die Hauptversionsnummer zurück.
* `minor(v)`: Gibt die Nebenversionsnummer zurück.
* `patch(v)`: Gibt die Patchversionsnummer zurück.
* `intersects(r1, r2, loose)`: Gibt true zurück, wenn sich die beiden bereitgestellten Bereiche oder Vergleichsoperatoren überschneiden.
* `parse(v)`: Versuchen Sie, eine Zeichenfolge als semantische Version zu analysieren, indem Sie entweder ein `SemVer`-Objekt oder `null` zurückgeben.

### <a name="comparison"></a>Vergleich

* `gt(v1, v2)`: `v1 > v2`
* `gte(v1, v2)`: `v1 >= v2`
* `lt(v1, v2)`: `v1 < v2`
* `lte(v1, v2)`: `v1 <= v2`
* `eq(v1, v2)`: `v1 == v2` Dies gilt, wenn sie logisch gleich sind, auch wenn sie nicht genau dieselbe Zeichenfolge sind.  Sie wissen bereits, wie Sie Zeichenfolgen vergleichen.
* `neq(v1, v2)`: `v1 != v2` Das Gegenstück zu `eq`.
* `cmp(v1, comparator, v2)`: Übergeben Sie eine Vergleichszeichenfolge. Daraufhin wird die entsprechende Funktion oben aufgerufen.  `"==="` und `"!=="` führen einen einfachen Zeichenfolgenvergleich aus, sind jedoch der Vollständigkeit halber enthalten.  Löst aus, wenn eine ungültige Vergleichszeichenfolge bereitgestellt wird.
* `compare(v1, v2)`: Gibt `0` zurück, wenn `v1 == v2` oder `1`, wenn `v1` größer ist, oder `-1`, wenn `v2` größer ist.  Wird bei Übergabe an `Array.sort()` in aufsteigender Reihenfolge sortiert.
* `rcompare(v1, v2)`: Das Umgekehrte des Vergleichs.  Sortiert ein Array von Versionen in absteigender Reihenfolge bei Übergabe an `Array.sort()`.
* `diff(v1, v2)`: Gibt die Differenz zwischen zwei Versionen anhand des Versionstyps zurück (`major`, `premajor`, `minor`, `preminor`, `patch`, `prepatch` oder `prerelease`), oder null, wenn die Versionen identisch sind.

### <a name="comparators"></a>Vergleichsoperatoren

* `intersects(comparator)`: Gibt true zurück, wenn sich die Vergleichsoperatoren überschneiden.

### <a name="ranges"></a>Bereiche

* `validRange(range)`: Gibt den gültigen Bereich zurück oder null, wenn er nicht gültig ist.
* `satisfies(version, range)`: Gibt true zurück, wenn die Version die Bedingungen des Bereichs erfüllt.
* `maxSatisfying(versions, range)`: Gibt die höchste Version in der Liste zurück, die die Bedingungen des Bereichs erfüllt, oder `null`, wenn dies bei keiner von ihnen der Fall ist.
* `minSatisfying(versions, range)`: Gibt die niedrigste Version in der Liste zurück, die die Bedingungen des Bereichs erfüllt, oder `null`, wenn dies bei keiner von ihnen der Fall ist.
* `minVersion(range)`: Gibt die niedrigste Version zurück, die möglicherweise mit dem angegebenen Bereich übereinstimmt.
* `gtr(version, range)`: Gibt `true` zurück, wenn die Version höher als alle im Bereich möglichen Versionen ist.
* `ltr(version, range)`: Gibt `true` zurück, wenn die Version niedriger als alle im Bereich möglichen Versionen ist.
* `outside(version, range, hilo)`: Gibt true zurück, wenn sich die Version entweder nach oben oder nach unten außerhalb der Grenzen des Bereichs befindet.  Das `hilo` Argument muss entweder die Zeichenfolge `'>'` oder `'<'` sein.  (Dies ist die Funktion, die von `gtr` und `ltr` aufgerufen wird.)
* `intersects(range)`: Gibt true zurück, wenn es in dem Bereich Vergleichsoperatoren gibt, die sich überschneiden.

Beachten Sie, dass, da Bereiche möglicherweise nicht zusammenhängend sind, eine Version möglicherweise nicht größer als ein Bereich, kleiner als ein Bereich ist, *oder* einen Bereich erfüllen kann!  Beispielsweise hätte der Bereich `1.2 <1.2.9 || >2.0.0` ein Loch von `1.2.9` bis `2.0.0`, sodass die Version `1.2.10` weder größer als der Bereich wäre (da `2.0.1` als höhere Version die Bedingungen erfüllt), noch kleiner als der Bereich wäre (da `1.2.8` als niedrigere Version die Bedingungen erfüllt) und auch die Bedingungen des Bereichs nicht erfüllt.

Wenn Sie wissen möchten, ob eine Version die Bedingungen eines Bereichs erfüllt oder nicht erfüllt, verwenden Sie die Funktion `satisfies(version, range)`.

### <a name="coercion"></a>Koersion

* `coerce(version)`: Wandelt eine Zeichenfolge nach Möglichkeit in SemVer um.

Dies zielt darauf ab, eine sehr tolerante Umwandlung einer Nicht-SemVer-Zeichenfolge in eine SemVer-Zeichenfolge bereitzustellen. Dabei wird nach der ersten Ziffer in einer Zeichenfolge gesucht, und es werden alle restlichen Zeichen verbraucht, sodass mindestens die Bedingungen einer teilweisen SemVer (z. B. `1`, `1.2`, `1.2.3`) bis zur maximal zulässigen Länge (256 Zeichen) erfüllt sind.  Längere Versionen werden einfach abgeschnitten (`4.6.3.9.2-alpha2` wird `4.6.3`).  Der gesamte umgebende Text wird einfach ignoriert (`v3.4 replaces v3.3.1` wird `3.4.0`).  Nur bei Text, der keine Ziffern enthält, schlägt die Umwandlung fehl (`version one` ist ungültig).  Die maximale Länge für jede SemVer-Komponente, die für eine Umwandlung in Betracht kommt, beträgt 16 Zeichen; längere Komponenten werden ignoriert (`10000000000000000.4.7.4` wird `4.7.4`).  Der Maximalwert für jede SemVer-Komponente lautet `Number.MAX_SAFE_INTEGER || (2**53 - 1)`; höhere Wertekomponenten sind ungültig (`9999999999999999.4.7.4` ist wahrscheinlich ungültig).
