---
ms.openlocfilehash: 0e4384a6edea7b3a580ffa5b32236b7f8b251834
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051383"
---
# <a name="combined-stream"></a>combined-stream

Ein Stream, der mehrere weitere Streams nacheinander sendet.

**NB** `combined-stream` funktioniert zurzeit nur bei Streams, Version 1. Es gibt fortlaufende Bemühungen, diese Bibliothek auf Streams, Version 2, umzustellen. Jede Hilfe ist willkommen. :) In der Zwischenzeit können Sie andere Bibliotheken erkunden, die Streams2-Unterstützung bei mehr oder weniger Kompatibilität mit `combined-stream` bieten.

- [combined-stream2](https://www.npmjs.com/package/combined-stream2): Ein direkt einsetzbarer Streams2-kompatibler Ersatz für das „combined-stream“-Modul.

- [multistream](https://www.npmjs.com/package/multistream): Ein Stream, der mehrere weitere Streams nacheinander sendet.

## <a name="installation"></a>Installation

``` bash
npm install combined-stream
```

## <a name="usage"></a>Verbrauch

Hier ist ein einfaches Beispiel, das zeigt, wie Sie zwei Dateien mithilfe von „combined-stream“ in einer Datei kombinieren können:

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create();
combinedStream.append(fs.createReadStream('file1.txt'));
combinedStream.append(fs.createReadStream('file2.txt'));

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

Während das vorstehende Beispiel hervorragend funktioniert, hält es alle Quellstreams so lange an, bis sie benötigt werden. Wenn das nicht geschehen soll, können Sie `pauseStreams` auf `false` festlegen:

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create({pauseStreams: false});
combinedStream.append(fs.createReadStream('file1.txt'));
combinedStream.append(fs.createReadStream('file2.txt'));

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

Was ist jedoch, wenn Sie noch nicht über alle Quellstreams verfügen oder die Ressourcen (Dateideskriptoren, Arbeitsspeicher usw.) dafür nicht sofort zuweisen möchten?
In diesem Fall können Sie einfach für einen Rückruf zur Bereitstellung des Streams sorgen, indem Sie eine `next()`-Funktion aufrufen:

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create();
combinedStream.append(function(next) {
  next(fs.createReadStream('file1.txt'));
});
combinedStream.append(function(next) {
  next(fs.createReadStream('file2.txt'));
});

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

## <a name="api"></a>API

### <a name="combinedstreamcreateoptions"></a>CombinedStream.create([options])

Gibt ein neues kombiniertes Streamobjekt zurück. Die verfügbaren Optionen lauten wie folgt:

* `maxDataSize`
* `pauseStreams`

Die Auswirkung dieser Optionen wird unten beschrieben.

### <a name="combinedstreampausestreams--true"></a>combinedStream.pauseStreams = `true`

Gibt an, ob Rückstau auf die zugrunde liegenden Streams angewendet werden soll. Wenn der Wert `false` festgelegt wurde, werden die zugrunde liegenden Streams nie angehalten. Wenn der Wert `true` festgelegt wurde, werden die zugrunde liegenden Streams angehalten, sofort nachdem sie angefügt wurden, und auch, wenn mit `delayedStream.pipe()` eine Drosselung durchgeführt werden soll.

### <a name="combinedstreammaxdatasize--2--1024--1024"></a>combinedStream.maxDataSize = `2 * 1024 * 1024`

Die maximale Menge von Bytes (oder Zeichen) zum Puffern bei allen Quellstreams.
Wenn dieser Wert überschritten wird, gibt `combinedStream` ein `'error'`-Ereignis aus.

### <a name="combinedstreamdatasize--0"></a>combinedStream.dataSize = `0`

Die Menge von Bytes (oder Zeichen), die zurzeit von `combinedStream` gepuffert wird.

### <a name="combinedstreamappendstream"></a>combinedStream.append(stream)

Fügt das angegebene `stream`-Objekt an das „combinedStream“-Objekt an. Wenn `pauseStreams` auf „true“ festgelegt wurde, wird dieser Stream außerdem sofort angehalten.

`streams` kann auch eine Funktion sein, die den Parameter `next` verwendet. `next` ist eine Funktion, die aufgerufen werden muss, um den `next`-Stream bereitzustellen (siehe das Beispiel oben).

Unabhängig davon, wie das `stream`-Objekt angefügt wird, fügt der kombinierte Stream daran immer einen `'error'`-Listener an. Deshalb müssen Sie dies nicht manuell erledigen.

Sonderfall: `stream` kann auch eine Zeichenfolge oder ein Puffer sein.

### <a name="combinedstreamwritedata"></a>combinedStream.write(data)

Sie sollten dies nicht aufrufen; `combinedStream` übernimmt automatisch das Piping der angefügten Datenströme in sich selbst.

### <a name="combinedstreamresume"></a>combinedStream.resume()

Bewirkt, dass `combinedStream` mit dem Ausgleich der von ihm verwalteten Streams beginnt. Die Funktion ist idempotent und gibt außerdem jedes Mal ein `'resume'`-Ereignis aus, das normalerweise an den Stream geht, der zurzeit ausgeglichen wird.

### <a name="combinedstreampause"></a>combinedStream.pause();

Wenn `combinedStream.pauseStreams` auf `false` festgelegt wurde, wird nichts ausgeführt.
Andernfalls wird ein `'pause'`-Ereignis ausgegeben, das zu dem zurzeit ausgeglichenen Stream geht, sodass sie damit Rückstau anwenden können.

### <a name="combinedstreamend"></a>combinedStream.end();

Legt `combinedStream.writable` auf „false“ fest, gibt ein `'end'`-Ereignis aus und entfernt alle Streams aus der Warteschlange.

### <a name="combinedstreamdestroy"></a>combinedStream.destroy();

Identisch mit `combinedStream.end()`, mit einer Ausnahme: Gibt ein `'close'`-Ereignis statt `'end'` aus.

## <a name="license"></a>Lizenz

combined-stream wird unter der MIT-Lizenz lizenziert.
